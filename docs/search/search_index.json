{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to KGHeartbeat API Docs","text":"<p>This is a library that helps you to analyze the quality of a Knowledge Graph directly in your Python application. See below how you can get started using the library. In the reference section you can find all the documentation relating to the various modules that make up the library. </p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install kgheartbeat\n</code></pre>"},{"location":"#get-started","title":"Get started","text":"<p>How check SPARQL endpoint availability with this library:</p> <pre><code>from kgheartbeat import KnowledgeGraph\n# Instanziate a KnowledgeGraph class, passing the id of the kg to be analyzed\nkg = KnowledgeGraph('dbpedia')\n# Call the check availability enpoint method\nresult = kg.checkEndpointAv()\n</code></pre> <p>For more examples go here: more examples</p>"},{"location":"AGAPI/","title":"AGAPI","text":""},{"location":"AGAPI/#kgheartbeat.AGAPI.getAllKg","title":"<code>getAllKg()</code>","text":"<p>Retrieve metadata of all KGs that are automatically discoverable from LODC and DataHub.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of dictionaries representing the metadata of all KGs.</p> Source code in <code>kgheartbeat\\AGAPI.py</code> <pre><code>def getAllKg():\n\"\"\"Retrieve metadata of all KGs that are automatically discoverable from LODC and DataHub.\n    Returns:\n        list: A list of dictionaries representing the metadata of all KGs.\n    \"\"\"\nurl = 'https://kgs-search-engine.herokuapp.com/brutalSearch?keyword='\ntry:\nresponse = requests.get(url)    \nif response.status_code == 200:\nprint(\"Connection to API successful and data recovered\")\nresponse = response.json()\nresults = response.get('results')\nreturn results\nelse:\nprint(\"Connection failed\")\nreturn False\nexcept:\nprint('Connection failed')\nreturn False\n</code></pre>"},{"location":"AGAPI/#kgheartbeat.AGAPI.getIdByName","title":"<code>getIdByName(keyword)</code>","text":"<p>Get the ID of the KG from its name.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>string</code> <p>The name or keyword of the KG.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of KG IDs matching the keyword.</p> Source code in <code>kgheartbeat\\AGAPI.py</code> <pre><code>def getIdByName(keyword):\n\"\"\"Get the ID of the KG from its name.\n    Args:\n        keyword (string): The name or keyword of the KG.\n    Returns:\n        list: A list of KG IDs matching the keyword.\n    \"\"\"\nurl = 'https://kgs-search-engine.herokuapp.com/brutalSearch?keyword=%s'%keyword\ntry:\nresponse = requests.get(url)    \nif response.status_code == 200:\nprint(\"Connection to API successful and data recovered\")\nresponse = response.json()\nresults = response.get('results')\nkgfound = []\nfor i in range(len(results)):\nd = results[i]\nid = d.get('id')\nkgfound.append(id)\nreturn kgfound\nelse:\nprint(\"Connection failed\")\nreturn False\nexcept:\nprint('Connection failed')\nreturn False\n</code></pre>"},{"location":"AGAPI/#kgheartbeat.AGAPI.getMetadati","title":"<code>getMetadati(idKG)</code>","text":"<p>Find the metadata about a KG from its id.</p> <p>Parameters:</p> Name Type Description Default <code>idKG</code> <code>string</code> <p>A string that represent the ID of KG that we want the metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that represent the metadata of the KG.</p> Source code in <code>kgheartbeat\\AGAPI.py</code> <pre><code>def getMetadati(idKG):\n\"\"\"Find the metadata about a KG from its id.\n    Args:\n        idKG (string): A string that represent the ID of KG that we want the metadata.\n    Returns:\n        string: A string that represent the metadata of the KG.\n    \"\"\"\nurl = 'https://kgs-search-engine.herokuapp.com/brutalSearch?keyword=%s'%idKG\ntry:\nresponse = requests.get(url)    \nif response.status_code == 200:\nresponse = response.json()\nresults = response.get('results')\nreturn results\nelse:\nprint(\"Connection failed to AGAPI\")\nreturn False\nexcept:\nprint('Connection failed to AGAPI')\nreturn False\n</code></pre>"},{"location":"AGAPI/#kgheartbeat.AGAPI.getNameKG","title":"<code>getNameKG(metadata)</code>","text":"<p>Extract the full name of the KG from the metadata.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The metadata of a KG.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>The full name of the KG.</p> Source code in <code>kgheartbeat\\AGAPI.py</code> <pre><code>def getNameKG(metadata):\n\"\"\"Extract the full name of the KG from the metadata.\n    Args:\n        metadata (dict): The metadata of a KG.\n    Returns:\n        string: The full name of the KG.\n    \"\"\"\nif isinstance(metadata,dict):\ntitle = metadata.get('title')\nreturn title\nelse: \nreturn False\n</code></pre>"},{"location":"AGAPI/#kgheartbeat.AGAPI.getSparqlEndpoint","title":"<code>getSparqlEndpoint(metadata)</code>","text":"<p>Extract the SPARQL endpoint URL from the metadata.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The metadata of a KG.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>The URL of the SPARQL endpoint.</p> Source code in <code>kgheartbeat\\AGAPI.py</code> <pre><code>def getSparqlEndpoint(metadata):\n\"\"\"Extract the SPARQL endpoint URL from the metadata.\n    Args:\n        metadata (dict): The metadata of a KG.\n    Returns:\n        string: The URL of the SPARQL endpoint.\n    \"\"\"\nif isinstance(metadata,dict):\nsparqlInfo = metadata.get('sparql')\nif not sparqlInfo:\nreturn False\naccessUrl = sparqlInfo.get('access_url')\nreturn accessUrl\n</code></pre>"},{"location":"DataHubAPI/","title":"DataHubAPI","text":""},{"location":"DataHubAPI/#kgheartbeat.DataHubAPI.checkRDFDump","title":"<code>checkRDFDump(jsonFile)</code>","text":"<p>Get the link to the RDF dump.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict which contains all KG metadata.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains all the links to other resources.</p> Source code in <code>kgheartbeat\\DataHubAPI.py</code> <pre><code>def checkRDFDump(jsonFile):\n\"\"\"Get the link to the RDF dump.\n    Args:\n        jsonFile (dict): A dict which contains all KG metadata.\n    Returns:\n        list: A list that contains all the links to other resources.\n    \"\"\"\nif isinstance(jsonFile,dict):\nresources = jsonFile.get('resources')\nif isinstance(resources,list):\nfor i in range(len(resources)):\nformat = resources[i].get('format')\nif format =='ZIP' or format == 'RAR:RDF' or format == 'RDF':\nreturn True\nelse:\nreturn False\nelse:\nreturn False\n</code></pre>"},{"location":"DataHubAPI/#kgheartbeat.DataHubAPI.getAuthor","title":"<code>getAuthor(jsonFile)</code>","text":"<p>Get the KG author from the KG metadata.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict that contains all KG metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that represent the KG author.</p> Source code in <code>kgheartbeat\\DataHubAPI.py</code> <pre><code>def getAuthor(jsonFile):\n\"\"\"Get the KG author from the KG metadata.\n    Args:\n        jsonFile (dict): A dict that contains all KG metadata.\n    Returns:\n        string: A string that represent the KG author.\n    \"\"\"\nif isinstance(jsonFile,dict):\nauthor = jsonFile.get('author')\nif isinstance(author,dict):\nauthorName = author.get('name')\nauthorEmail = author.get('email')\nauthorStr = 'Name: %s, Email:%s'%(authorName,authorEmail)\nreturn authorStr\nelse:\nreturn False\nelse:\nreturn False\n</code></pre>"},{"location":"DataHubAPI/#kgheartbeat.DataHubAPI.getDataPackage","title":"<code>getDataPackage(idDataset)</code>","text":"<p>Get the JSON file with all matadata about the KG from its id.</p> <p>Parameters:</p> Name Type Description Default <code>idDataset</code> <code>string</code> <p>A string that represent the ID of KG that we want to fetch the metadata.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dict that contains all the metadata of the KG.</p> Source code in <code>kgheartbeat\\DataHubAPI.py</code> <pre><code>def getDataPackage(idDataset):\n\"\"\"Get the JSON file with all matadata about the KG from its id.\n    Args:\n        idDataset (string): A string that represent the ID of KG that we want to fetch the metadata.\n    Returns:\n        dict: A dict that contains all the metadata of the KG.\n    \"\"\"\napi_url = \"https://old.datahub.io/dataset/%s/datapackage.json\" %idDataset\ntry:\nresponse = requests.get(api_url)\nif response.status_code == 200:\nresponseApi = response.json()\nreturn responseApi\nelif response.status_code == 404:\nprint(\"Dataset not found on DataHub\")\nreturn False\nexcept:\nprint('Failed to connect to DataHub')\nreturn False\n</code></pre>"},{"location":"DataHubAPI/#kgheartbeat.DataHubAPI.getDescription","title":"<code>getDescription(jsonFile)</code>","text":"<p>Get the KG description.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict that contains the KG metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that is the description of the data in the KG.</p> Source code in <code>kgheartbeat\\DataHubAPI.py</code> <pre><code>def getDescription(jsonFile):\n\"\"\"Get the KG description.\n    Args:\n        jsonFile (dict): A dict that contains the KG metadata.\n    Returns:\n        string: A string that is the description of the data in the KG.\n    \"\"\"\nif isinstance(jsonFile,dict):\ndescription = jsonFile.get('description','absent')\nreturn description\nelse:\nreturn False\n</code></pre>"},{"location":"DataHubAPI/#kgheartbeat.DataHubAPI.getExternalLinks","title":"<code>getExternalLinks(jsonFile)</code>","text":"<p>Get all the external links related to the KG.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>jsonFile</code> <p>A dict which contains all the metadata of the KH.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dict which contains the links and the info about the links.</p> Source code in <code>kgheartbeat\\DataHubAPI.py</code> <pre><code>def getExternalLinks(jsonFile):\n\"\"\"Get all the external links related to the KG.\n    Args:\n        jsonFile (jsonFile): A dict which contains all the metadata of the KH.\n    Returns:\n        dict: A dict which contains the links and the info about the links.\n    \"\"\"\nif isinstance(jsonFile,dict):\nextras = {}\nextras = jsonFile.get('extras')\nif isinstance(extras,dict):\nextras = {i:extras[i] for i in extras if'links:' in i} #CLEAN THE DICTIONARY FROM OTHER ENTRY THAT ISN'T LINKS\nfor i in extras.copy().keys():\nextras[i.removeprefix('links:')] = extras.pop(i,None) #REMOVING THE PREFIX LINK\nreturn extras\nelse:\nreturn False\n</code></pre>"},{"location":"DataHubAPI/#kgheartbeat.DataHubAPI.getExtrasLang","title":"<code>getExtrasLang(jsonFile)</code>","text":"<p>Get the languages of the data in the KG.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict which contains all the KG metadata.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dict that contains the languages supported by the KG .</p> Source code in <code>kgheartbeat\\DataHubAPI.py</code> <pre><code>def getExtrasLang(jsonFile):\n\"\"\"Get the languages of the data in the KG.\n    Args:\n        jsonFile (dict): A dict which contains all the KG metadata.\n    Returns:\n        dict: A dict that contains the languages supported by the KG .\n    \"\"\"\nextras = jsonFile.get('extras')\nif isinstance(extras,dict):\nextras = {i:extras[i] for i in extras if'language' in i}\nreturn extras\nelse:\nreturn False\n</code></pre>"},{"location":"DataHubAPI/#kgheartbeat.DataHubAPI.getKeywords","title":"<code>getKeywords(jsonFile)</code>","text":"<p>Get the KG keyowords.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict which contains all the KG metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that is the concatenation of all the KG keywords.</p> Source code in <code>kgheartbeat\\DataHubAPI.py</code> <pre><code>def getKeywords(jsonFile):\n\"\"\"Get the KG keyowords.\n    Args:\n        jsonFile (dict): A dict which contains all the KG metadata.\n    Returns:\n        string: A string that is the concatenation of all the KG keywords.\n    \"\"\"\nif isinstance(jsonFile,dict):\nkeywords = jsonFile.get('keywords')\nreturn keywords\nelse:\nreturn False\n</code></pre>"},{"location":"DataHubAPI/#kgheartbeat.DataHubAPI.getLicense","title":"<code>getLicense(jsonFile)</code>","text":"<p>Get the license info from the metadata recovered.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict that contains all KG metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that represent the KG license.</p> Source code in <code>kgheartbeat\\DataHubAPI.py</code> <pre><code>def getLicense(jsonFile):\n\"\"\"\n    Get the license info from the metadata recovered.\n    Args:\n        jsonFile (dict): A dict that contains all KG metadata.\n    Returns:\n        string: A string that represent the KG license.\n    \"\"\"\nif isinstance(jsonFile,dict):\nlicense = jsonFile.get('license')\nif isinstance(license,dict):\nlicenseTitle = license.get('title')\ntype = license.get('type')\nlicenseStr = '%s - %s -'%(licenseTitle,type)\nreturn licenseStr\nelse:\nreturn False\nelse:\nreturn False\n</code></pre>"},{"location":"DataHubAPI/#kgheartbeat.DataHubAPI.getNameKG","title":"<code>getNameKG(metadata)</code>","text":"<p>Get the KG name form the kg metadata.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>A dict that contains all KG metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that represent the KG name</p> Source code in <code>kgheartbeat\\DataHubAPI.py</code> <pre><code>def getNameKG(metadata):\n\"\"\"Get the KG name form the kg metadata.\n    Args:\n        metadata (dict): A dict that contains all KG metadata.\n    Returns:\n        string: A string that represent the KG name\n    \"\"\"\nif isinstance(metadata,dict):\ntitle = metadata.get('title')\nreturn title\nelse:\nreturn False\n</code></pre>"},{"location":"DataHubAPI/#kgheartbeat.DataHubAPI.getOtherResources","title":"<code>getOtherResources(jsonFile)</code>","text":"<p>Get all the other resources related with the KG (e.g. examples of SPARQL query) and delete the duplicate links.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict which contains all the KG metadata.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of dict that contains all the links to other resources.</p> Source code in <code>kgheartbeat\\DataHubAPI.py</code> <pre><code>def getOtherResources(jsonFile):\n\"\"\"Get all the other resources related with the KG (e.g. examples of SPARQL query) and delete the duplicate links.\n    Args:\n        jsonFile (dict): A dict which contains all the KG metadata.\n    Returns:\n        list: A list of dict that contains all the links to other resources.\n    \"\"\"\nif isinstance(jsonFile,dict):\nresources = []\nresources = jsonFile.get('resources')\nif isinstance(resources,list):\nfor i in range(len(resources)):  #DELETING UNNECESSARY ELEMENT FROM THE DICTIONARY \nresources[i].pop('name',None)\nresources[i].pop('hash',None)\nreturn resources\nelse:\nreturn False\nelse: \nreturn False\n</code></pre>"},{"location":"DataHubAPI/#kgheartbeat.DataHubAPI.getSPARQLEndpoint","title":"<code>getSPARQLEndpoint(jsonFile)</code>","text":"<p>Get the SPARQL endpoint from the KG metadata.    </p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict which contains all the KG metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that is the SPARQL endpoint link.</p> Source code in <code>kgheartbeat\\DataHubAPI.py</code> <pre><code>def getSPARQLEndpoint(jsonFile):\n\"\"\"Get the SPARQL endpoint from the KG metadata.    \n    Args:\n        jsonFile (dict): A dict which contains all the KG metadata.\n    Returns:\n        string: A string that is the SPARQL endpoint link.\n    \"\"\"\nif isinstance(jsonFile,dict):\nresources = jsonFile.get('resources')\nif isinstance(resources,list):\nfor i in range(len(resources)):\nd = resources[i]\nformat = d.get('format','')\nname = d.get('name','')\nif format == 'api/sparql' or 'sparql' in name:\nurl = d.get('path',False)\nreturn url\nreturn False\nelse:\nreturn False\nelse:\nreturn False\n</code></pre>"},{"location":"DataHubAPI/#kgheartbeat.DataHubAPI.getSources","title":"<code>getSources(jsonFile)</code>","text":"<p>Get the KG source from the KG metadata.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict that contains all KG metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that represent the KG author.</p> Source code in <code>kgheartbeat\\DataHubAPI.py</code> <pre><code>def getSources(jsonFile):\n\"\"\"Get the KG source from the KG metadata.\n    Args:\n        jsonFile (dict): A dict that contains all KG metadata.\n    Returns:\n        string: A string that represent the KG author.\n    \"\"\"\nif isinstance(jsonFile,dict):\nsources = jsonFile.get('sources',False)\nif isinstance(sources,list):\nreturn sources[0]\nelse:\nreturn False\nelse:\nreturn False\n</code></pre>"},{"location":"DataHubAPI/#kgheartbeat.DataHubAPI.getTriples","title":"<code>getTriples(jsonFile)</code>","text":"<p>Get the number of KG triples indicated in the metadata.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict which contains all KG metadata.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>An integer that is the number of triples in the KG.</p> Source code in <code>kgheartbeat\\DataHubAPI.py</code> <pre><code>def getTriples(jsonFile):\n\"\"\"Get the number of KG triples indicated in the metadata.\n    Args:\n        jsonFile (dict): A dict which contains all KG metadata.\n    Returns:\n        int: An integer that is the number of triples in the KG.\n    \"\"\"\nif isinstance(jsonFile,dict):\nextras = jsonFile.get('extras')\nif isinstance(extras,dict):\ntriples = extras.get('triples',0)\nreturn triples\nelse:\nreturn False\nelse:\nreturn False\n</code></pre>"},{"location":"Graph/","title":"Graph","text":""},{"location":"Graph/#kgheartbeat.Graph.buildGraph","title":"<code>buildGraph()</code>","text":"<p>Constructs a graph that has all the automatically recoverable KGs as nodes and the respective relationships with the other KGs as edge.</p> <p>Returns:</p> Name Type Description <code>Graph</code> <p>A graph with all the KGs automatically discoverable with its relationship.</p> Source code in <code>kgheartbeat\\Graph.py</code> <pre><code>def buildGraph():\n\"\"\"Constructs a graph that has all the automatically recoverable KGs as nodes and the respective relationships with the other KGs as edge.\n    Returns:\n        Graph: A graph with all the KGs automatically discoverable with its relationship.\n    \"\"\"\nallKg = AGAPI.getAllKg()\nidList = []\nG = nx.Graph()\nfor i in range(len(allKg)):\nelement = allKg[i]\nid = element.get('id')\nidList.append(id)\nfor j in range(len(idList)):\nexternalLinks = aggregator.getExternalLinks(idList[j])\nexLinksObj = utils.toObjectExternalLinks(externalLinks)\nprint(idList[j])\nif isinstance(exLinksObj,list) and len(exLinksObj) &gt; 0:\nfor k in range(len(exLinksObj)):\nlink = exLinksObj[k]\nvalue = str(link.value)\nvalue = re.sub(\"[^\\d\\.]\", \"\",value)\nif value == '':\nvalue = 0\nvalue = int(value)\nG.add_edge(idList[j],link.nameKG,weight=value)\n#pos = nx.spring_layout(G, k=0.8)\n#nx.draw(G,pos,with_labels=True,width=0.4,node_size=400)\n#plt.show()\nreturn G\n</code></pre>"},{"location":"Graph/#kgheartbeat.Graph.getCentrality","title":"<code>getCentrality(graph, idKg)</code>","text":"<p>Compute the centrality of the node in the Graph of all KGs.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent A graph with all the KGs automatically discoverable with its relationship.</p> required <code>idKG</code> <code>string</code> <p>A string that represent the id of the KG whose page rank we want to calculate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>A float that is the centality of the KG in the graph og all KGs.</p> Source code in <code>kgheartbeat\\Graph.py</code> <pre><code>def getCentrality(graph,idKg):\n\"\"\"Compute the centrality of the node in the Graph of all KGs.\n    Args:\n        graph (Graph): A Graph that represent A graph with all the KGs automatically discoverable with its relationship.\n        idKG (string): A string that represent the id of the KG whose page rank we want to calculate.\n    Returns:\n        float: A float that is the centality of the KG in the graph og all KGs.\n    \"\"\"\ndegreeCentrality = nx.degree_centrality(graph)\nreturn degreeCentrality.get(idKg)\n</code></pre>"},{"location":"Graph/#kgheartbeat.Graph.getClusteringCoefficient","title":"<code>getClusteringCoefficient(graph, idKG)</code>","text":"<p>Compute the clustering coefficient of a KG in the graph of KGs (the higher it is, the more it means that the node's ability to form a clique is high).</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent A graph with all the KGs automatically discoverable with its relationship.</p> required <code>idKG</code> <code>string</code> <p>A string that represent the id of the KG whose page rank we want to calculate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>A float that is the clustering coefficient of a KG in the graph of all KGs.</p> Source code in <code>kgheartbeat\\Graph.py</code> <pre><code>def getClusteringCoefficient(graph,idKG):\n\"\"\"Compute the clustering coefficient of a KG in the graph of KGs (the higher it is, the more it means that the node's ability to form a clique is high).\n    Args:\n        graph (Graph): A Graph that represent A graph with all the KGs automatically discoverable with its relationship.\n        idKG (string): A string that represent the id of the KG whose page rank we want to calculate.\n    Returns:\n        float: A float that is the clustering coefficient of a KG in the graph of all KGs.\n    \"\"\"\nclusteringCoefficient = nx.clustering(graph,idKG)\nreturn clusteringCoefficient\n</code></pre>"},{"location":"Graph/#kgheartbeat.Graph.getDegreeOfConnection","title":"<code>getDegreeOfConnection(graph, idKg)</code>","text":"<p>Compute the degree of connection of a KG (number of edges).</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent A graph with all the KGs automatically discoverable with its relationship.</p> required <code>idKG</code> <code>string</code> <p>A string that represent the id of the KG whose page rank we want to calculate.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>A integer that is the number of edges of the KG.</p> Source code in <code>kgheartbeat\\Graph.py</code> <pre><code>def getDegreeOfConnection(graph,idKg):\n\"\"\"Compute the degree of connection of a KG (number of edges).\n    Args:\n        graph (Graph): A Graph that represent A graph with all the KGs automatically discoverable with its relationship.\n        idKG (string): A string that represent the id of the KG whose page rank we want to calculate.\n    Returns:\n        int: A integer that is the number of edges of the KG.\n    \"\"\"\ndegree = graph.degree(nbunch=idKg)\nreturn degree\n</code></pre>"},{"location":"Graph/#kgheartbeat.Graph.getPageRank","title":"<code>getPageRank(graph, idKg)</code>","text":"<p>Compute the PageRank of a KG. This is a value in range [0;10].</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent A graph with all the KGs automatically discoverable with its relationship.</p> required <code>idKG</code> <code>string</code> <p>A string that represent the id of the KG whose page rank we want to calculate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>A float that is the PageRank of the KG.</p> Source code in <code>kgheartbeat\\Graph.py</code> <pre><code>def getPageRank(graph,idKg):\n\"\"\"Compute the PageRank of a KG. This is a value in range [0;10].\n    Args:\n        graph (Graph): A Graph that represent A graph with all the KGs automatically discoverable with its relationship.\n        idKG (string): A string that represent the id of the KG whose page rank we want to calculate.\n    Returns:\n        float: A float that is the PageRank of the KG.\n    \"\"\"\npr = nx.pagerank(graph)\nreturn pr.get(idKg)\n</code></pre>"},{"location":"Graph/#kgheartbeat.Graph.storeEdges","title":"<code>storeEdges(graph, nodelist)</code>","text":"<p>This function store info about all edges for every KG in the graph with all the KGs automatically discoverable (this is used for visualize the graph in the web app).</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent A graph with all the KGs automatically discoverable with its relationship.</p> required <code>nodelist</code> <code>list</code> <p>A list that contains all the IDs of the KGs whose subgraph we want to extract.</p> required Source code in <code>kgheartbeat\\Graph.py</code> <pre><code>def storeEdges(graph,nodelist):\n\"\"\"This function store info about all edges for every KG in the graph with all the KGs automatically discoverable (this is used for visualize the graph in the web app).\n    Args:\n        graph (Graph): A Graph that represent A graph with all the KGs automatically discoverable with its relationship.\n        nodelist (list): A list that contains all the IDs of the KGs whose subgraph we want to extract. \n    \"\"\"\nsave_path = './Graphs Visualization JS/Subgraphs'\nfor i in range(len(nodelist)):\nnewFilename = re.sub(r'[\\\\/*?:\"&lt;&gt;|]',\"\",nodelist[i])\nremove_punctuation_map = dict((ord(char), None) for char in '\\/*?:\"&lt;&gt;|')\nnewFilename = newFilename.translate(remove_punctuation_map)\nremove_punctuation_map = dict((ord(char), None) for char in string.punctuation)\nnewFilename = newFilename.translate(remove_punctuation_map)\ncompleteName = os.path.join(save_path, newFilename+\".txt\")\ne = graph.edges(nodelist[i])\ne = str(e)\ne = e.replace('(','[')\ne = e.replace(')',']')\ne = e.replace(\"'\",'\"')\nwith open(completeName,'w',encoding=\"utf-8\") as f:\nf.write(e)\n</code></pre>"},{"location":"LODCloudAPI/","title":"LODCloudAPI","text":""},{"location":"LODCloudAPI/#kgheartbeat.LODCloudAPI.getAuthor","title":"<code>getAuthor(jsonFile)</code>","text":"<p>Get the KG author from the KG metadata.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict that contains all KG metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that represent the KG author.</p> Source code in <code>kgheartbeat\\LODCloudAPI.py</code> <pre><code>def getAuthor(jsonFile):\n\"\"\"Get the KG author from the KG metadata.\n    Args:\n        jsonFile (dict): A dict that contains all KG metadata.\n    Returns:\n        string: A string that represent the KG author.\n    \"\"\"\nif isinstance(jsonFile,dict):\nowner = jsonFile.get('owner')\nif isinstance(owner,dict):\nname = owner.get('name')\nif (not name):\nname = 'absent'    \nemail = owner.get('email')\nif (not email):\nemail = 'absent'\nownerStr = 'Name: %s, email: %s'%(name,email)\nreturn ownerStr\nelse:\nreturn False\nelse:\nreturn False\n</code></pre>"},{"location":"LODCloudAPI/#kgheartbeat.LODCloudAPI.getDescription","title":"<code>getDescription(jsonFile)</code>","text":"<p>Get the KG description.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict that contains the KG metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that is the description of the data in the KG.</p> Source code in <code>kgheartbeat\\LODCloudAPI.py</code> <pre><code>def getDescription(jsonFile):\n\"\"\"Get the KG description.\n    Args:\n        jsonFile (dict): A dict that contains the KG metadata.\n    Returns:\n        string: A string that is the description of the data in the KG.\n    \"\"\"\nif isinstance(jsonFile,dict):\nen = jsonFile.get('description','absent')\nif isinstance(en,dict):\ndescription = en.get('en','absent')\nreturn description\nelse:\nreturn 'absent'\nelse:\nreturn False\n</code></pre>"},{"location":"LODCloudAPI/#kgheartbeat.LODCloudAPI.getExternalLinks","title":"<code>getExternalLinks(jsonFile)</code>","text":"<p>Get all the external links related to the KG.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>jsonFile</code> <p>A dict which contains all the metadata of the KH.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dict which contains the links and the info about the links.</p> Source code in <code>kgheartbeat\\LODCloudAPI.py</code> <pre><code>def getExternalLinks(jsonFile):\n\"\"\"Get all the external links related to the KG.\n    Args:\n        jsonFile (jsonFile): A dict which contains all the metadata of the KH.\n    Returns:\n        dict: A dict which contains the links and the info about the links.\n    \"\"\"\nif isinstance(jsonFile,dict):\nlinks = jsonFile.get('links',0)\nif isinstance(links,list):\nreturn links\nelse:\nreturn links\nelse:\nreturn False\n</code></pre>"},{"location":"LODCloudAPI/#kgheartbeat.LODCloudAPI.getJSONMetadata","title":"<code>getJSONMetadata(idKG)</code>","text":"<p>Get the JSON file with all matadata about the KG from its id.</p> <p>Parameters:</p> Name Type Description Default <code>idKG</code> <code>string</code> <p>A string that represent the ID of KG that we want to fetch the metadata.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dict that contains all the metadata of the KG.</p> Source code in <code>kgheartbeat\\LODCloudAPI.py</code> <pre><code>def getJSONMetadata(idKG):\n\"\"\"Get the JSON file with all matadata about the KG from its id.\n    Args:\n        idKG (string): A string that represent the ID of KG that we want to fetch the metadata.\n    Returns:\n        dict: A dict that contains all the metadata of the KG.\n    \"\"\"\nurl = 'https://lod-cloud.net/json/%s'%idKG\ntry:\nresponse = requests.get(url)\nif response.status_code == 200:\njsonMetadata = response.json()\nreturn jsonMetadata\nelif response.status_code == 404:\nprint('Dataset not found on LOD Cloud')\nreturn False\nexcept:\nprint('Failed to connect  to LOD Cloud')\nreturn False\n</code></pre>"},{"location":"LODCloudAPI/#kgheartbeat.LODCloudAPI.getKeywords","title":"<code>getKeywords(jsonfile)</code>","text":"<p>Get the KG keyowords.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict which contains all the KG metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that is the concatenation of all the KG keywords.</p> Source code in <code>kgheartbeat\\LODCloudAPI.py</code> <pre><code>def getKeywords(jsonfile):\n\"\"\"Get the KG keyowords.\n    Args:\n        jsonFile (dict): A dict which contains all the KG metadata.\n    Returns:\n        string: A string that is the concatenation of all the KG keywords.\n    \"\"\"\nif isinstance(jsonfile,dict):\nkeywords = jsonfile.get('keywords')\nreturn keywords\nelse:\nreturn False\n</code></pre>"},{"location":"LODCloudAPI/#kgheartbeat.LODCloudAPI.getLicense","title":"<code>getLicense(jsonFile)</code>","text":"<p>Get the license info from the metadata recovered.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict that contains all KG metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that represent the KG license.</p> Source code in <code>kgheartbeat\\LODCloudAPI.py</code> <pre><code>def getLicense(jsonFile):\n\"\"\"\n    Get the license info from the metadata recovered.\n    Args:\n        jsonFile (dict): A dict that contains all KG metadata.\n    Returns:\n        string: A string that represent the KG license.\n    \"\"\"\nif isinstance(jsonFile,dict):\nlicense = jsonFile.get('license')\nif (not license):\nreturn False\nelse:\nreturn license\nelse:\nreturn False\n</code></pre>"},{"location":"LODCloudAPI/#kgheartbeat.LODCloudAPI.getNameKG","title":"<code>getNameKG(metadata)</code>","text":"<p>Get the KG name form the kg metadata.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>A dict that contains all KG metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that represent the KG name</p> Source code in <code>kgheartbeat\\LODCloudAPI.py</code> <pre><code>def getNameKG(metadata):\n\"\"\"Get the KG name form the kg metadata.\n    Args:\n        metadata (dict): A dict that contains all KG metadata.\n    Returns:\n        string: A string that represent the KG name\n    \"\"\"\nif isinstance(metadata,dict):\ntitle = metadata.get('title')\nreturn title\nelse:\nreturn False\n</code></pre>"},{"location":"LODCloudAPI/#kgheartbeat.LODCloudAPI.getOtherResources","title":"<code>getOtherResources(jsonFile)</code>","text":"<p>Get all the other resources related with the KG (e.g. examples of SPARQL query) and delete the duplicate links.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict which contains all the KG metadata.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of dict that contains all the links to other resources.</p> Source code in <code>kgheartbeat\\LODCloudAPI.py</code> <pre><code>def getOtherResources(jsonFile):  \n\"\"\"Get all the other resources related with the KG (e.g. examples of SPARQL query) and delete the duplicate links.\n    Args:\n        jsonFile (dict): A dict which contains all the KG metadata.\n    Returns:\n        list: A list of dict that contains all the links to other resources.\n    \"\"\"\nif isinstance(jsonFile,dict):\nfullDownload = []\nexample = []\nresources = []\nfullDownload = jsonFile.get('full_download')\nfor i in range(len(fullDownload)):\nd = fullDownload[i]\nd['access_url'] = d.pop('download_url',None)  #RENAME THE KEY VALUE TO HAVE THE SAME NAME OF THE FIELD\nd['type'] = 'full_download'\nexample = jsonFile.get('example')\notherDownload = jsonFile.get('other_download')\nresources = example + otherDownload + fullDownload\nfor i in range (len(resources)):   #DELETING UNNECESSARY ELEMENT FROM THE DICTIONARY \nresources[i].pop('mirror',None)\nresources[i].pop('status',None)\nresources[i].pop('_id',None)\nd = resources[i]\nd['path'] = d['access_url']   #RENAME THE KEY VALUE TO HAVE THE SAME NAME OF THE FIELD IN THE DATAHUB METADATA\ndel d['access_url']\nd['format'] = d.pop('media_type',None)\nreturn resources\nelse:\nreturn False\n</code></pre>"},{"location":"LODCloudAPI/#kgheartbeat.LODCloudAPI.getSPARQLEndpoint","title":"<code>getSPARQLEndpoint(jsonFile)</code>","text":"<p>Get the SPARQL endpoint from the KG metadata.    </p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict which contains all the KG metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that is the SPARQL endpoint link.</p> Source code in <code>kgheartbeat\\LODCloudAPI.py</code> <pre><code>def getSPARQLEndpoint(jsonFile):\n\"\"\"Get the SPARQL endpoint from the KG metadata.    \n    Args:\n        jsonFile (dict): A dict which contains all the KG metadata.\n    Returns:\n        string: A string that is the SPARQL endpoint link.\n    \"\"\"\nif isinstance(jsonFile,dict):\nlistSparql = jsonFile.get('sparql')\nif isinstance(listSparql,list):\nif len(listSparql) &gt;= 1:\nd = listSparql[0]\nurl = d.get('access_url')\nreturn url\nelse:\nreturn False\nelse:\nreturn False\nelse:\nreturn False\n</code></pre>"},{"location":"LODCloudAPI/#kgheartbeat.LODCloudAPI.getSource","title":"<code>getSource(jsonFile)</code>","text":"<p>Get the KG source from the KG metadata.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict that contains all KG metadata.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dict that contains all info about the KG source.</p> Source code in <code>kgheartbeat\\LODCloudAPI.py</code> <pre><code>def getSource(jsonFile):\n\"\"\"Get the KG source from the KG metadata.\n    Args:\n        jsonFile (dict): A dict that contains all KG metadata.\n    Returns:\n        dict: A dict that contains all info about the KG source.\n    \"\"\"\nif isinstance(jsonFile,dict):\nwebsite = jsonFile.get('website')\nif(not website):\nwebsite = 'absent'\ncontactPoint = jsonFile.get('contact_point')\nif isinstance(contactPoint,dict):\ncontactPoint[\"web\"] = website \nname = contactPoint.get('name')\nemail = contactPoint.get('email')\nif(not name):\nname = 'absent'\nif(not email):\nemail = 'absent'\nreturn contactPoint\nelse:\nreturn False\nelse:\nreturn False\n</code></pre>"},{"location":"LODCloudAPI/#kgheartbeat.LODCloudAPI.getSourceDict","title":"<code>getSourceDict(jsonFile)</code>","text":"<p>Get the KG source from the KG metadata.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict that contains all KG metadata.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dict that contains all info about the KG source.</p> Source code in <code>kgheartbeat\\LODCloudAPI.py</code> <pre><code>def getSourceDict(jsonFile):\n\"\"\"Get the KG source from the KG metadata.\n    Args:\n        jsonFile (dict): A dict that contains all KG metadata.\n    Returns:\n        dict: A dict that contains all info about the KG source.\n    \"\"\"\nif isinstance(jsonFile,dict):\nwebsite = jsonFile.get('website')\nif(not website):\nwebsite = 'absent'\ncontactPoint = jsonFile.get('contact_point')\nif isinstance(contactPoint,dict):\ncontactPoint[\"web\"] = website \nreturn contactPoint\nelse:\nreturn False\nelse:\nreturn False\n</code></pre>"},{"location":"LODCloudAPI/#kgheartbeat.LODCloudAPI.getTriples","title":"<code>getTriples(jsonFile)</code>","text":"<p>Get the number of KG triples indicated in the metadata.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile</code> <code>dict</code> <p>A dict which contains all KG metadata.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>An integer that is the number of triples in the KG.</p> Source code in <code>kgheartbeat\\LODCloudAPI.py</code> <pre><code>def getTriples(jsonFile):\n\"\"\"Get the number of KG triples indicated in the metadata.\n    Args:\n        jsonFile (dict): A dict which contains all KG metadata.\n    Returns:\n        int: An integer that is the number of triples in the KG.\n    \"\"\"\nif isinstance(jsonFile,dict):\ntriples = jsonFile.get('triples',0)\nreturn triples\nelse:\nreturn False\n</code></pre>"},{"location":"LOVAPI/","title":"LOVAPI","text":""},{"location":"LOVAPI/#kgheartbeat.LOVAPI.autocompleteTerm","title":"<code>autocompleteTerm(term)</code>","text":"<p>Search similar terms based on the term given as input.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>string</code> <p>A string that represent a term used in the KG analyzed.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dict that contains a list of terms similar to the term passed as input.</p> Source code in <code>kgheartbeat\\LOVAPI.py</code> <pre><code>def autocompleteTerm(term):\n\"\"\"Search similar terms based on the term given as input.\n    Args:\n        term (string): A string that represent a term used in the KG analyzed.\n    Returns: \n        dict: A dict that contains a list of terms similar to the term passed as input.\n    \"\"\"\nurl = 'https://lov.linkeddata.es/dataset/lov/api/v2/term/autocomplete?q=%s'%term\ntry:\nh = {'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.76 Safari/537.36'}\nresponse = requests.get(url,headers=h)\nif response.status_code == 200:\njsonResult = response.json()\nreturn jsonResult\nelif response.status_code == 404:\nprint('Error in running the query on LOV')\nreturn False \nexcept:\nprint('Failed to connect to Linked Open Vocabularies')\nreturn False\n</code></pre>"},{"location":"LOVAPI/#kgheartbeat.LOVAPI.autocompleteVocab","title":"<code>autocompleteVocab(vocab)</code>","text":"<p>Search similar vocabularies based on the vocabulary given as input.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>string</code> <p>A string that represent a vocabulary used in the KG analyzed.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dict that contains a list of vocabularies similar to the term passed as input.</p> Source code in <code>kgheartbeat\\LOVAPI.py</code> <pre><code>def autocompleteVocab(vocab):\n\"\"\"Search similar vocabularies based on the vocabulary given as input.\n    Args:\n        term (string): A string that represent a vocabulary used in the KG analyzed.\n    Returns: \n        dict: A dict that contains a list of vocabularies similar to the term passed as input.\n    \"\"\"\nurl = 'https://lov.linkeddata.es/dataset/lov/api/v2/vocabulary/autocomplete?q=%s'%vocab\ntry:\nresponse = requests.get(url)\nif response.status_code == 200:\njsonResult = response.json()\nreturn jsonResult\nelif response.status_code == 404:\nprint('Error in running the query on LOV')\nreturn False \nexcept:\nprint('Failed to connect to Linked Open Vocabularies')\nreturn False\n</code></pre>"},{"location":"LOVAPI/#kgheartbeat.LOVAPI.findVocabulary","title":"<code>findVocabulary(vocab)</code>","text":"<p>Look for a vocabulary in the LOV to see if it is considered standard or is a new defined vocabulary.</p> <p>Parameters:</p> Name Type Description Default <code>vocab</code> <code>string</code> <p>A string that represent a vocabulary used in the KG analyzed.</p> required <p>Returns:</p> Name Type Description <code>boolean</code> <p>A boolean that is True if the vocabulary is in the LOV, False otherwise.</p> Source code in <code>kgheartbeat\\LOVAPI.py</code> <pre><code>def findVocabulary(vocab):\n\"\"\"Look for a vocabulary in the LOV to see if it is considered standard or is a new defined vocabulary.\n    Args:\n        vocab (string): A string that represent a vocabulary used in the KG analyzed.\n    Returns: \n        boolean: A boolean that is True if the vocabulary is in the LOV, False otherwise.\n    \"\"\"\nvocabularies = getAllVocab()\nfor i in range(len(vocabularies)):\nd = vocabularies[i]\nnsp = d.get('nsp')\nuri = d.get('uri')\nif nsp == vocab:\nreturn True\nif uri == vocab:\nreturn True\nreturn False\n</code></pre>"},{"location":"LOVAPI/#kgheartbeat.LOVAPI.getAllVocab","title":"<code>getAllVocab()</code>","text":"<p>Search for all standard vocabularies included in the LOV.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dict that contains all vocabularies considered standard by the LOV.</p> Source code in <code>kgheartbeat\\LOVAPI.py</code> <pre><code>def getAllVocab():\n\"\"\"Search for all standard vocabularies included in the LOV.\n    Returns: \n        dict: A dict that contains all vocabularies considered standard by the LOV.\n    \"\"\"\nurl = 'https://lov.linkeddata.es/dataset/lov/api/v2/vocabulary/list'\ntry:\nresponse = requests.get(url)\nif response.status_code == 200:\njsonResult = response.json()\nreturn jsonResult\nelif response.status_code == 404:\nprint('Error in running the query on LOV')\nreturn False \nexcept:\nprint('Failed to connect to Linked Open Vocabularies')\nreturn False\n</code></pre>"},{"location":"LOVAPI/#kgheartbeat.LOVAPI.searchTermsList","title":"<code>searchTermsList(terms)</code>","text":"<p>Look for a terms in the files with all terms downloaded form the LOV to see if it are considered standard or is a new defined terms.</p> <p>Parameters:</p> Name Type Description Default <code>terms</code> <code>list</code> <p>A list that represent all terms  used in the KG analyzed.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains all terms that aren't considered standard for the LOV.</p> Source code in <code>kgheartbeat\\LOVAPI.py</code> <pre><code>@log_in_out\ndef searchTermsList(terms):\n\"\"\"Look for a terms in the files with all terms downloaded form the LOV to see if it are considered standard or is a new defined terms.\n    Args:\n        terms (list): A list that represent all terms  used in the KG analyzed.\n    Returns: \n        list: A list that contains all terms that aren't considered standard for the LOV.\n    \"\"\"\nhere = os.path.dirname(os.path.abspath(__file__))\nlov1 = os.path.join(here,'lov1.txt')\nlov2 = os.path.join(here,'lov2.txt')\nnewTerms = []\nwith open(lov1, 'r',encoding='utf-8') as f1:\nwith open(lov2, 'r',encoding='utf-8') as f2:\ndata1 = set(f1.read().splitlines())\ndata2 = set(f2.read().splitlines())\nfor i in range(len(terms)):\nif terms[i] not in data1 and terms[i] not in data2:\nnewTerms.append(terms[i])\nreturn newTerms\n</code></pre>"},{"location":"VoIDAnalyses/","title":"VoIDAnalyses","text":""},{"location":"VoIDAnalyses/#kgheartbeat.VoIDAnalyses.getContributors","title":"<code>getContributors(graph)</code>","text":"<p>Find triples which contain the contributors of the KG.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent a VoID file parsed with all its triples.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains all the contributors (or the contributor) of the KG.</p> Source code in <code>kgheartbeat\\VoIDAnalyses.py</code> <pre><code>def getContributors(graph):\n\"\"\"Find triples which contain the contributors of the KG.\n    Args:\n        graph (Graph): A Graph that represent a VoID file parsed with all its triples.\n    Returns:\n        list: A list that contains all the contributors (or the contributor) of the KG.\n    \"\"\"\ncontributors = []\nfor s,p,o in graph:\nif p == DCTERMS.contributor or p == DC.contributor:\no = str(o)\ncontributors.append(o)\nif len(contributors) &gt; 0:       \nreturn contributors\nelse:\nreturn 'absent'\n</code></pre>"},{"location":"VoIDAnalyses/#kgheartbeat.VoIDAnalyses.getCreationDate","title":"<code>getCreationDate(graph)</code>","text":"<p>Find triples with a predicate that indicate the KG creation date.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent a VoID file parsed with all it's triples.</p> required <p>Returns:</p> Name Type Description <code>Date</code> <p>A Date object that represent the KG creation date.</p> Source code in <code>kgheartbeat\\VoIDAnalyses.py</code> <pre><code>def getCreationDate(graph):\n\"\"\"Find triples with a predicate that indicate the KG creation date.\n    Args:\n        graph (Graph): A Graph that represent a VoID file parsed with all it's triples.\n    Returns:\n        Date: A Date object that represent the KG creation date.\n    \"\"\"\ndate = []\nfor s,p,o in graph:\nif p == DCTERMS.created or DCTERMS.issued:\no = str(o)\nmatch = re.search(r'\\d{4}-\\d{2}-\\d{2}', o)\nif match is not None:\no = datetime.datetime.strptime(match.group(), '%Y-%m-%d').date()\ndate.append(o)\nif len(date) &gt; 0:       \nreturn min(date)\nelse:\nreturn 'absent'\n</code></pre>"},{"location":"VoIDAnalyses/#kgheartbeat.VoIDAnalyses.getCreators","title":"<code>getCreators(graph)</code>","text":"<p>Find triples which contain the creators of the KG.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent a VoID file parsed with all its triples.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains all the creators (or the creator) of the KG.</p> Source code in <code>kgheartbeat\\VoIDAnalyses.py</code> <pre><code>def getCreators(graph):\n\"\"\"Find triples which contain the creators of the KG.\n    Args:\n        graph (Graph): A Graph that represent a VoID file parsed with all its triples.\n    Returns:\n        list: A list that contains all the creators (or the creator) of the KG.\n    \"\"\"\ncreators = []\nfor s,p,o in graph:\nif p == DCTERMS.creator or DC.creator:\no = str(o)\ncreators.append(o)\nif len(creators) &gt; 0:       \nreturn creators\nelse:\nreturn 'absent'\n</code></pre>"},{"location":"VoIDAnalyses/#kgheartbeat.VoIDAnalyses.getDataDump","title":"<code>getDataDump(graph)</code>","text":"<p>Find triples which contain the url of the KG dump file.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent a VoID file parsed with all its triples.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that represent a link to the KG dump</p> Source code in <code>kgheartbeat\\VoIDAnalyses.py</code> <pre><code>def getDataDump(graph):\n\"\"\"Find triples which contain the url of the KG dump file.\n    Args:\n        graph (Graph): A Graph that represent a VoID file parsed with all its triples.\n    Returns:\n        string: A string that represent a link to the KG dump\n    \"\"\"\nfor s,p,o in graph:\nif p == VOID.dataDump:\no = str(o)\nreturn o\nreturn 'absent'\n</code></pre>"},{"location":"VoIDAnalyses/#kgheartbeat.VoIDAnalyses.getFrequency","title":"<code>getFrequency(graph)</code>","text":"<p>Find triples which contain the frequency update of the KG.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent a VoID file parsed with all its triples.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that represent the frequency update of the KG.</p> Source code in <code>kgheartbeat\\VoIDAnalyses.py</code> <pre><code>def getFrequency(graph):\n\"\"\"Find triples which contain the frequency update of the KG.\n    Args:\n        graph (Graph): A Graph that represent a VoID file parsed with all its triples.\n    Returns:\n        string: A string that represent the frequency update of the KG.\n    \"\"\"\nfor s,p,o in graph:\nif p == DCTERMS.Frequency or p == DCTERMS.accrualPeriodicity:\no = str(o)\nif o != '':       \nreturn o\nreturn 'absent'\n</code></pre>"},{"location":"VoIDAnalyses/#kgheartbeat.VoIDAnalyses.getLanguage","title":"<code>getLanguage(graph)</code>","text":"<p>Find triples which contain the languages of the KG.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent a VoID file parsed with all its triples.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains all the languages supported by the KG.</p> Source code in <code>kgheartbeat\\VoIDAnalyses.py</code> <pre><code>def getLanguage(graph):\n\"\"\"Find triples which contain the languages of the KG.\n    Args:\n        graph (Graph): A Graph that represent a VoID file parsed with all its triples.\n    Returns:\n        list: A list that contains all the languages supported by the KG.\n    \"\"\"\nformats = []\nfor s,p,o in graph:\nif p == DCTERMS.language or DC.language:\no = str(o)\nformats.append(o)\nif len(formats) &gt; 0:       \nreturn formats\nelse:\nreturn 'absent'\n</code></pre>"},{"location":"VoIDAnalyses/#kgheartbeat.VoIDAnalyses.getLicense","title":"<code>getLicense(graph)</code>","text":"<p>Find triples which contain the license of the KG (machine-redeable).</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent a VoID file parsed with all its triples.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that represent the machine-redeable license of a KG.</p> Source code in <code>kgheartbeat\\VoIDAnalyses.py</code> <pre><code>def getLicense(graph):\n\"\"\"Find triples which contain the license of the KG (machine-redeable).\n    Args:\n        graph (Graph): A Graph that represent a VoID file parsed with all its triples.\n    Returns:\n        string: A string that represent the machine-redeable license of a KG.\n    \"\"\"\nfor s,p,o in graph:\nif p == DCTERMS.license:\no = str(o)\nreturn o\nreturn 'absent'\n</code></pre>"},{"location":"VoIDAnalyses/#kgheartbeat.VoIDAnalyses.getModificationDate","title":"<code>getModificationDate(graph)</code>","text":"<p>Find triples with a predicate that indicate the KG last modification date.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent a VoID file parsed with all it's triples.</p> required <p>Returns:</p> Name Type Description <code>Date</code> <p>A Date object that represent the KG creation date.</p> Source code in <code>kgheartbeat\\VoIDAnalyses.py</code> <pre><code>def getModificationDate(graph):\n\"\"\"Find triples with a predicate that indicate the KG last modification date.\n    Args:\n        graph (Graph): A Graph that represent a VoID file parsed with all it's triples.\n    Returns:\n        Date: A Date object that represent the KG creation date.\n    \"\"\"\ndate = []\nfor s,p,o in graph:\nif p == DCTERMS.modified:\no = str(o)\nmatch = re.search(r'\\d{4}-\\d{2}-\\d{2}', o)\nif match is not None:\no = datetime.datetime.strptime(match.group(), '%Y-%m-%d').date()\ndate.append(o)\nif len(date) &gt; 0:       \nreturn max(date)\nelse:\nreturn 'absent'\n</code></pre>"},{"location":"VoIDAnalyses/#kgheartbeat.VoIDAnalyses.getNumEntities","title":"<code>getNumEntities(graph)</code>","text":"<p>Find triples which contain the number of entities of the KG.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent a VoID file parsed with all its triples.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that represent the number of entities in the KG.</p> Source code in <code>kgheartbeat\\VoIDAnalyses.py</code> <pre><code>def getNumEntities(graph):\n\"\"\"Find triples which contain the number of entities of the KG.\n    Args:\n        graph (Graph): A Graph that represent a VoID file parsed with all its triples.\n    Returns:\n        string: A string that represent the number of entities in the KG.\n    \"\"\"\nfor s,p,o in graph:\nif p == VOID.entities:\no = str(o)\nif o != '':       \nreturn o\nelse:\nreturn 'absent'\nreturn 'information abaout entities absent'\n</code></pre>"},{"location":"VoIDAnalyses/#kgheartbeat.VoIDAnalyses.getPublishers","title":"<code>getPublishers(graph)</code>","text":"<p>Find triples which contain the publichers of the KG.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent a VoID file parsed with all its triples.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains all the publishers (or the publicher) of the KG.</p> Source code in <code>kgheartbeat\\VoIDAnalyses.py</code> <pre><code>def getPublishers(graph):\n\"\"\"Find triples which contain the publichers of the KG.\n    Args:\n        graph (Graph): A Graph that represent a VoID file parsed with all its triples.\n    Returns:\n        list: A list that contains all the publishers (or the publicher) of the KG.\n    \"\"\"\npublishers = []\nfor s,p,o in graph:\nif p == DCTERMS.publisher or p == DC.publisher:\no = str(o)\npublishers.append(o)\nif len(publishers) &gt; 0:       \nreturn publishers\nelse:\nreturn 'absent'\n</code></pre>"},{"location":"VoIDAnalyses/#kgheartbeat.VoIDAnalyses.getSerializationFormats","title":"<code>getSerializationFormats(graph)</code>","text":"<p>Find triples which contain the seriaization formats of the KG.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent a VoID file parsed with all its triples.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains all the serialization formats available for the KG.</p> Source code in <code>kgheartbeat\\VoIDAnalyses.py</code> <pre><code>def getSerializationFormats(graph):\n\"\"\"Find triples which contain the seriaization formats of the KG.\n    Args:\n        graph (Graph): A Graph that represent a VoID file parsed with all its triples.\n    Returns:\n        list: A list that contains all the serialization formats available for the KG.\n    \"\"\"\nformats = []\nfor s,p,o in graph:\nif p == VOID.feature or DCAT.mediaType:\no = str(o)\nformats.append(o)\nif len(formats) &gt; 0:       \nreturn formats\nelse:\nreturn 'absent'\n</code></pre>"},{"location":"VoIDAnalyses/#kgheartbeat.VoIDAnalyses.getUriRegex","title":"<code>getUriRegex(graph)</code>","text":"<p>Find triples which contain the regex of URI in the KG.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent a VoID file parsed with all its triples.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains all the regex that match the URI of the KG.</p> Source code in <code>kgheartbeat\\VoIDAnalyses.py</code> <pre><code>def getUriRegex(graph):\n\"\"\"Find triples which contain the regex of URI in the KG.\n    Args:\n        graph (Graph): A Graph that represent a VoID file parsed with all its triples.\n    Returns:\n        list: A list that contains all the regex that match the URI of the KG.\n    \"\"\"\nregex = []\nfor s,p,o in graph:\nif p == VOID.uriRegexPattern or VOID.uriSpace:\no = str(o)\nregex.append(o)\nif len(regex) &gt; 0:       \nreturn regex\nelse:\nreturn 'absent'\n</code></pre>"},{"location":"VoIDAnalyses/#kgheartbeat.VoIDAnalyses.getVocabularies","title":"<code>getVocabularies(graph)</code>","text":"<p>Find triples with a predicate that indicate the vocabulary used in the KG.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent a VoID file parsed with all it's triples.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list with all vocabularies used by the KG.</p> Source code in <code>kgheartbeat\\VoIDAnalyses.py</code> <pre><code>def getVocabularies(graph):\n\"\"\"Find triples with a predicate that indicate the vocabulary used in the KG.\n    Args:\n        graph (Graph): A Graph that represent a VoID file parsed with all it's triples.\n    Returns:\n        list: A list with all vocabularies used by the KG.\n    \"\"\"\nvocabularies = []\nfor s, p, o in graph:\nif p == VOID.vocabulary:\no = str(o)\nvocabularies.append(o)\nnewVocabularies = []\n[newVocabularies.append(x) for x in vocabularies if x not in newVocabularies] #DUPLICATE REMOVAL IF PRESENT\nreturn(newVocabularies)\n</code></pre>"},{"location":"VoIDAnalyses/#kgheartbeat.VoIDAnalyses.parseVoID","title":"<code>parseVoID(url)</code>","text":"<p>Parse the file VoID from an url and convert triples in a Graph object.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>string</code> <p>A string that represent a url of a VoID file available on Internet.</p> required <p>Returns:</p> Name Type Description <code>Graph</code> <p>A Graph object that contain all the triples in the VoID file.</p> Source code in <code>kgheartbeat\\VoIDAnalyses.py</code> <pre><code>def parseVoID(url):\n\"\"\"Parse the file VoID from an url and convert triples in a Graph object.\n    Args:\n        url (string): A string that represent a url of a VoID file available on Internet.\n    Returns:\n        Graph: A Graph object that contain all the triples in the VoID file.\n    \"\"\"\ng = Graph()\ng.parse(url)\nreturn g\n</code></pre>"},{"location":"VoIDAnalyses/#kgheartbeat.VoIDAnalyses.parseVoIDTtl","title":"<code>parseVoIDTtl(url)</code>","text":"<p>Parse the file VoID with the .ttl extension from an url and convert triples in a Graph object.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>string</code> <p>A string that represent a url of a VoID file available on Internet.</p> required <p>Returns:</p> Name Type Description <code>Graph</code> <p>A Graph object that contain all the triples in the VoID file.</p> Source code in <code>kgheartbeat\\VoIDAnalyses.py</code> <pre><code>def parseVoIDTtl(url):\n\"\"\"Parse the file VoID with the .ttl extension from an url and convert triples in a Graph object.\n    Args:\n        url (string): A string that represent a url of a VoID file available on Internet.\n    Returns:\n        Graph: A Graph object that contain all the triples in the VoID file.\n    \"\"\"\ng = Graph()\ng.parse(url,format='ttl')\nreturn g\n</code></pre>"},{"location":"VoIDAnalyses/#kgheartbeat.VoIDAnalyses.printVoID","title":"<code>printVoID(graph)</code>","text":"<p>Print all the triples in the VoID file parsed.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A Graph that represent a VoID file parsed with all it's triples.</p> required Source code in <code>kgheartbeat\\VoIDAnalyses.py</code> <pre><code>def printVoID(graph):\n\"\"\"Print all the triples in the VoID file parsed.\n    Args:\n        graph (Graph): A Graph that represent a VoID file parsed with all it's triples.\n    \"\"\"\nfor s,p,o in graph:\nprint(s,p,o)\n</code></pre>"},{"location":"aggregator/","title":"Aggregator","text":""},{"location":"aggregator/#kgheartbeat.aggregator.getAuthor","title":"<code>getAuthor(metadata)</code>","text":"<p>Get the KG author from the KG metadata.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>A dict that contains all KG metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that represent the KG author.</p> Source code in <code>kgheartbeat\\aggregator.py</code> <pre><code>def getAuthor(metadata):\n\"\"\"Get the KG author from the KG metadata.\n    Args:\n        metadata (dict): A dict that contains all KG metadata.\n    Returns:\n        string: A string that represent the KG author.\n    \"\"\"\nauthorDH = DataHubAPI.getAuthor(metadata)\nauthorLODC = LODCloudAPI.getAuthor(metadata)\nif authorDH != False:\nreturn authorDH\nelif authorLODC != False:\nreturn authorLODC\nelse:\nreturn False\n</code></pre>"},{"location":"aggregator/#kgheartbeat.aggregator.getDataPackage","title":"<code>getDataPackage(idKG)</code>","text":"<p>Get the JSON file with all matadata about the KG from its id, both from LODC and DataHub. If metadata are available on both the services, then return the ones from DataHub.</p> <p>Parameters:</p> Name Type Description Default <code>idKG</code> <code>string</code> <p>A string that represent the ID of KG that we want the metadata.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dict that contains all the metadata of the KG.</p> Source code in <code>kgheartbeat\\aggregator.py</code> <pre><code>def getDataPackage(idKG):\n\"\"\"Get the JSON file with all matadata about the KG from its id, both from LODC and DataHub.\n    If metadata are available on both the services, then return the ones from DataHub.\n    Args:\n        idKG (string): A string that represent the ID of KG that we want the metadata.\n    Returns:\n        dict: A dict that contains all the metadata of the KG.\n    \"\"\"\nmetadataDH = DataHubAPI.getDataPackage(idKG)\nmetadataLODC = LODCloudAPI.getJSONMetadata(idKG)\nif isinstance(metadataDH,dict):\nreturn metadataDH\nelif isinstance(metadataLODC,dict):\nreturn metadataLODC\nelse:\nreturn False\n</code></pre>"},{"location":"aggregator/#kgheartbeat.aggregator.getDescription","title":"<code>getDescription(metadata)</code>","text":"<p>Get the KG description.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>A dict that contains the KG metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that is the description of the data in the KG.</p> Source code in <code>kgheartbeat\\aggregator.py</code> <pre><code>def getDescription(metadata):\n\"\"\"Get the KG description.\n    Args:\n        metadata (dict): A dict that contains the KG metadata.\n    Returns:\n        string: A string that is the description of the data in the KG.\n    \"\"\"\ndescriptionDH = DataHubAPI.getDescription(metadata)\ndescriptionLODC = LODCloudAPI.getDescription(metadata)\nif descriptionDH != False and not isinstance(descriptionDH,dict):\nreturn descriptionDH\nelif descriptionLODC != False:\nreturn descriptionLODC\nelse:\nreturn False\n</code></pre>"},{"location":"aggregator/#kgheartbeat.aggregator.getExternalLinks","title":"<code>getExternalLinks(idKG)</code>","text":"<p>Get all the external links related to the KG.</p> <p>Parameters:</p> Name Type Description Default <code>idKG</code> <code>string</code> <p>A string that contains the KG id.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dict that which the links and the info about the links.</p> Source code in <code>kgheartbeat\\aggregator.py</code> <pre><code>def getExternalLinks(idKG):\n\"\"\"Get all the external links related to the KG.\n    Args:\n        idKG (string): A string that contains the KG id.\n    Returns:\n        dict: A dict that which the links and the info about the links.\n    \"\"\"\nmetadataDH = DataHubAPI.getDataPackage(idKG)\nmetadataLODC = LODCloudAPI.getJSONMetadata(idKG)\nlinksDH = DataHubAPI.getExternalLinks(metadataDH)\nif linksDH == False or linksDH is None:\nlinksDH = {}   #BECAUSE IS USED TO CLEAN THE RESULTS FROM LODCLOUD (IN CASE DATAHUB NOT HAVE EXTERNAL LINKS)\nlinksLODC = LODCloudAPI.getExternalLinks(metadataLODC)\nif isinstance(linksLODC,list):\nfor i in range(len(linksLODC)):\nd = linksLODC[i]\nkey = d.get('target')\nvalue = d.get('value')\nlinksDH[key] = value\nreturn linksDH\nelse:\nreturn linksDH\n</code></pre>"},{"location":"aggregator/#kgheartbeat.aggregator.getExtrasLanguage","title":"<code>getExtrasLanguage(idKg)</code>","text":"<p>Get the languages of the data in the KG.</p> <p>Parameters:</p> Name Type Description Default <code>idKG</code> <code>str</code> <p>A string that represents the KG id.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dict that contains the languages supported by the KG .</p> Source code in <code>kgheartbeat\\aggregator.py</code> <pre><code>def getExtrasLanguage(idKg):\n\"\"\"Get the languages of the data in the KG.\n    Args:\n        idKG (str): A string that represents the KG id.\n    Returns:\n        dict: A dict that contains the languages supported by the KG .\n    \"\"\"\nmetadataDH = DataHubAPI.getDataPackage(idKg)\nif isinstance(metadataDH,dict):\nlanguage = DataHubAPI.getExtrasLang(metadataDH)\nif isinstance(language,dict):\nreturn language\nelse:\nreturn 'absent'\nelse:\nreturn 'absent'\n</code></pre>"},{"location":"aggregator/#kgheartbeat.aggregator.getKeywords","title":"<code>getKeywords(idKg)</code>","text":"<p>Get the KG keyowords.</p> <p>Parameters:</p> Name Type Description Default <code>idKG</code> <code>string</code> <p>A string that represent the KG id.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that is the concatenation of all the KG keywords.</p> Source code in <code>kgheartbeat\\aggregator.py</code> <pre><code>def getKeywords(idKg):\n\"\"\"Get the KG keyowords.\n    Args:\n        idKG (string): A string that represent the KG id.\n    Returns:\n        string: A string that is the concatenation of all the KG keywords.\n    \"\"\"\nmetadataDH = DataHubAPI.getDataPackage(idKg)\nmetadataLODC = LODCloudAPI.getJSONMetadata(idKg)\nkeywordsDH = DataHubAPI.getKeywords(metadataDH)\nkeywordsLODC = LODCloudAPI.getKeywords(metadataLODC)\nkeywords = keywordsDH + keywordsLODC\nreturn keywords\n</code></pre>"},{"location":"aggregator/#kgheartbeat.aggregator.getLicense","title":"<code>getLicense(metadata)</code>","text":"<p>Get the license info from the metadata recovered.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>A dict that contains all KG metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that represent the KG license.</p> Source code in <code>kgheartbeat\\aggregator.py</code> <pre><code>def getLicense(metadata):\n\"\"\"\n    Get the license info from the metadata recovered.\n    Args:\n        metadata (dict): A dict that contains all KG metadata.\n    Returns:\n        string: A string that represent the KG license.\n    \"\"\"\nlicenseDH = DataHubAPI.getLicense(metadata)\nlicenseLODC = LODCloudAPI.getLicense(metadata)\nif licenseDH != False:\nreturn licenseDH\nelif licenseLODC != False:\nreturn licenseLODC\nelse:\nreturn False\n</code></pre>"},{"location":"aggregator/#kgheartbeat.aggregator.getNameKG","title":"<code>getNameKG(metadata)</code>","text":"<p>Get the KG name form the kg metadata.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>A dict that contains all KG metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that represent the KG name</p> Source code in <code>kgheartbeat\\aggregator.py</code> <pre><code>def getNameKG(metadata):\n\"\"\"Get the KG name form the kg metadata.\n    Args:\n        metadata (dict): A dict that contains all KG metadata.\n    Returns:\n        string: A string that represent the KG name\n    \"\"\"\nnameDH = DataHubAPI.getNameKG(metadata)\nnameLODC = LODCloudAPI.getNameKG(metadata)\nif nameDH != False:\nreturn nameDH\nelif nameLODC != False:\nreturn nameLODC\nelse:\nreturn False\n</code></pre>"},{"location":"aggregator/#kgheartbeat.aggregator.getOtherResources","title":"<code>getOtherResources(idKG)</code>","text":"<p>Get all the other resources related with the KG (e.g. examples of SPARQL query).</p> <p>Parameters:</p> Name Type Description Default <code>idKG</code> <code>string</code> <p>A string that contains the KG id.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list which contains all the links to other resources.</p> Source code in <code>kgheartbeat\\aggregator.py</code> <pre><code>def getOtherResources(idKG):\n\"\"\"Get all the other resources related with the KG (e.g. examples of SPARQL query).\n    Args:\n        idKG (string): A string that contains the KG id.\n    Returns:\n        list: A list which contains all the links to other resources.\n    \"\"\"\nmetadataDH = DataHubAPI.getDataPackage(idKG)\nmetadataLODC = LODCloudAPI.getJSONMetadata(idKG)\notResourcesDH = DataHubAPI.getOtherResources(metadataDH)\notResourcesLODC = LODCloudAPI.getOtherResources(metadataLODC)\nif otResourcesDH == False:\notResourcesDH = []\nif otResourcesLODC == False:\notResourcesLODC = []\notherResources = utils.mergeResources(otResourcesDH,otResourcesLODC)\nreturn otherResources\n</code></pre>"},{"location":"aggregator/#kgheartbeat.aggregator.getSPARQLEndpoint","title":"<code>getSPARQLEndpoint(idKG)</code>","text":"<p>Get the SPARQL endpoint from the KG id, try to find on both DataHub and LODCloud. If the link is available on both the service, is selected the one from LODCloud    </p> <p>Parameters:</p> Name Type Description Default <code>idKG</code> <code>string</code> <p>A string that contains the KG id.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that is the SPARQL endpoint link.</p> Source code in <code>kgheartbeat\\aggregator.py</code> <pre><code>def getSPARQLEndpoint(idKG):\n\"\"\"Get the SPARQL endpoint from the KG id, try to find on both DataHub and LODCloud.\n    If the link is available on both the service, is selected the one from LODCloud    \n    Args:\n        idKG (string): A string that contains the KG id.\n    Returns:\n        string: A string that is the SPARQL endpoint link.\n    \"\"\"\nmetadataLODC = LODCloudAPI.getJSONMetadata(idKG)\nmetadataDH = DataHubAPI.getDataPackage(idKG)\nendpointLODC = LODCloudAPI.getSPARQLEndpoint(metadataLODC)  \nendpointDH = DataHubAPI.getSPARQLEndpoint(metadataDH)\nif endpointLODC != False:\nif isinstance(endpointLODC,str):\nif endpointLODC != '':\nreturn endpointLODC\nelse:\nreturn endpointDH\nelse:\nreturn endpointDH\nelse:\nreturn endpointDH\n</code></pre>"},{"location":"aggregator/#kgheartbeat.aggregator.getSource","title":"<code>getSource(metadata)</code>","text":"<p>Get the KG source from the KG metadata.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>A dict that contains all KG metadata.</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>A string that represent the KG author.</p> Source code in <code>kgheartbeat\\aggregator.py</code> <pre><code>def getSource(metadata):\n\"\"\"Get the KG source from the KG metadata.\n    Args:\n        metadata (dict): A dict that contains all KG metadata.\n    Returns:\n        string: A string that represent the KG author.\n    \"\"\"\nsourcesDH = DataHubAPI.getSources(metadata)\nsourcesLODC = LODCloudAPI.getSourceDict(metadata)\nif sourcesDH != False:\nreturn sourcesDH\nelif sourcesLODC != False:\nreturn sourcesLODC\nelse:\nreturn False\n</code></pre>"},{"location":"aggregator/#kgheartbeat.aggregator.getTriples","title":"<code>getTriples(metadata)</code>","text":"<p>Get the number of KG triples from the  metadata.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>A dict that contains all KG metadata.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>A integer that represent the number of triples in the KG.</p> Source code in <code>kgheartbeat\\aggregator.py</code> <pre><code>def getTriples(metadata):\n\"\"\"Get the number of KG triples from the  metadata.\n    Args:\n        metadata (dict): A dict that contains all KG metadata.\n    Returns:\n        int: A integer that represent the number of triples in the KG.\n    \"\"\"\nnumTriplesDH = DataHubAPI.getTriples(metadata)\nnumTriplesLODC = LODCloudAPI.getTriples(metadata)\nif numTriplesDH != False:\nreturn numTriplesDH\nelif numTriplesLODC != False:\nreturn numTriplesLODC\nelse:\nreturn False\n</code></pre>"},{"location":"knowledge_graph/","title":"Knowledge graph","text":""},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph","title":"<code>KnowledgeGraph</code>","text":"Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>class KnowledgeGraph:\ndef __init__(self,id):\nself.id = id\n#AVAILABILITY\ndef checkEndpointAv(self):\n\"\"\"Check the SPARQL endpoint availability.\n        Returns:\n            bool: A boolean that represent the SPARQL endpoint availability (True = Online and False = Offline).\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\ntry:\nresult = q.checkEndPoint(url)\nif isinstance(result,bytes):\nnewUrl = utils.checkRedirect(url)\nresult = q.checkEndPoint(newUrl)\nif isinstance(result,bytes):\navailable = False\nelse:\navailable = True\nelse:\navailable = True\nexcept:\navailable = False\nreturn available\ndef checkDownload(self):\n\"\"\"\n        Check if the link for download the KG as rdf dump is present and online.\n        Returns:\n            bool: A boolean that represent the dump link availability (True = Online and False = Offline). \n        \"\"\"\nresources = aggregator.getOtherResources(self.id)\nresources = utils.insertAvailability(resources)\navailable = utils.checkAvailabilityForDownload(resources)\nreturn available\ndef checkInactiveLinks(self):\n\"\"\"\n        Check if there are inactive link associated with the KG.\n        Returns:\n            bool: A boolean that represent if there are any inactive links associeted with the KG.\n        \"\"\"\nresources = aggregator.getOtherResources(self.id)\nresources = utils.insertAvailability(resources)\nresourcesObj = utils.toObjectResources(resources)\ninactiveLink = False\nfor link in resourcesObj:\nif link.status == 'offline':\ninactiveLink = True\nreturn inactiveLink\ndef getURIsDef(self):\n\"\"\"\n        Check the URIs deferenceability. This test is done based on 5000 triples retrieved randomly from the SPARQL endpoint, and for each triple a GET requests is performed.\n        Returns:\n            float: A float that represent a value which is the ratio between: number of deferenceable URIs and number of total URIs considered.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\ntry:\ndefCount = 0\nuriCount = 0\nuris = q.getUris(url) #QUERY THAT GET 5000 RANDOM URI FROM THE ENDPOINT \nfor uri in uris:\nif utils.checkURI(uri) == True:\nuriCount = uriCount + 1\ntry:\nresponse = requests.get(uri,headers={\"Accept\":\"application/rdf+xml\"},stream=True)\nif response.status_code == 200:\ndefCount = defCount +1\nexcept:\ncontinue\nif uriCount &gt; 0:        \ndefValue = defCount / uriCount\nelse:\ndefValue = 'No uri retrieved from the endpoint'\nexcept: #IF QUERY FAILS (BECUASE SPARQL 1.1 IS NOT SUPPORTED) TRY TO CHECK THE DEFERETIABILITY BY FILTERING THE TRIPLES RECOVERED FOR OTHER CALCULATION (IF THEY ARE BEEN RECOVERED)\ntry:\nuriCount = 0\ndefCount = 0\nallTriples = q.getAllTriplesSPO(url)\nfor i in range(5000):\ns = allTriples[i].get('s')\nvalue = s.get('value')\nif utils.checkURI(value):\nuriCount = uriCount + 1\ntry:\nresponse = requests.get(value,headers={\"Accept\":\"application/rdf+xml\"},stream=True)\nif response.status_code == 200:\ndefCount = defCount +1\nexcept:\ncontinue\nif uriCount &gt; 0:\ndefValue = defCount / uriCount\nelse:\ndefValue = 'No uri found'\nexcept:\ndefValue = 'Could not process formulated query on indicated endpoint'\nreturn defValue\n#LICENSING\ndef getLicenseMR(self):\n\"\"\"\n        Return the machine-redeable license of the kg, checking on the SPARQL endpopint, in the metadata and in the void file .\n        Returns:\n            string: A string that represent the machine-redeable license of the KG.\n        \"\"\"\nmetadata = aggregator.getDataPackage(self.id)\nlicenseM = aggregator.getLicense(metadata) #CHECKING IN THE METADATA\nif isinstance(licenseM,str): \nreturn licenseM   #IF LICENSE IS INDICATED IN THE METADATE, RETURN IT\ntry:\nlicenseQ = q.checkLicenseMR2(aggregator.getSPARQLEndpoint(self.id)) #CHECKING ON THE SPARQL ENDPOINT\nif isinstance(licenseQ,list):\nreturn licenseQ\nexcept Exception as e:\nreturn e\nresources = aggregator.getOtherResources(self.id)\nresources = utils.insertAvailability(resources)\notResources = utils.toObjectResources(resources)\nurlV = utils.getUrlVoID(otResources)\nif isinstance(urlV,str):  # CHECKING IF VOID FILE IS AVAILABLE\ntry:\nvoidFile = VoIDAnalyses.parseVoID(urlV)\nvoid = True\nexcept:\ntry:\nvoidFile = VoIDAnalyses.parseVoIDTtl(urlV)\nvoid = True\nexcept:\nvoid = False \nif void == True:\nlicenseV = VoIDAnalyses.getLicense(voidFile)  #GETTING LICENSE FROM THE VOID FILE\nif isinstance(licenseV,str):\nreturn licenseV\ndef getLicenseHR(self):\n\"\"\"\n        Get the human-redeable license, search for a label on the triples in the KG.\n        Returns:\n            list: A list which contain all the human-redeable license founded in the KG.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\ntry:\nlicense = q.checkLicenseHR(url)\nexcept Exception as e:\nlicense = e\nreturn license\n#INTERLINKING\ndef getDegreeOfConnection(self):\n\"\"\"\n        Get the degree of connection of kg in the graph constructed with all the kg discoverable.\n        At the first call of a function of the interlinking metric a file is created in the directory which contains the graph with all kg discoverable, this is to avoid the construction of the graph every time from scratch.\n        Returns: \n            int: An integer that represent the degree of connection.\n        \"\"\"\ngraph = utils.checkGraphFile()\ndegree = Graph.getDegreeOfConnection(graph,self.id)\nreturn degree\ndef getClusteringCoefficient(self):\n\"\"\"\n        Get the clustering coefficient of kg in the graph constructed with all the kg discoverable.\n        At the first call of a function of the interlinking metric a file is created in the directory which contains the graph with all kg discoverable, this is to avoid the construction of the graph every time from scratch.\n        Returns:\n            float: A float that represent a local clustering coefficient.\n        \"\"\"\ngraph = utils.checkGraphFile()\nlcc = Graph.getClusteringCoefficient(graph,self.id)\nlcc = \"%.3f\"%lcc\nreturn float(lcc)\ndef getCentrality(self):\n\"\"\"\n        Get the centrality of kg in the graph constructed with all the kg discoverable.\n        At the first call of a function of the interlinking metric a file is created in the directory which contains the graph with all kg discoverable, this is to avoid the construction of the graph every time from scratch.\n        Returns:\n            float: A float that is the centrality of the KG.\n        \"\"\"\ngraph = utils.checkGraphFile()\ncentrality = Graph.getCentrality(graph,self.id)\ncentratility = \"%.3f\"%centrality\nreturn float(centrality)\ndef getSameAsChains(self):\n\"\"\"\n        Return the number of sameAs chains, counting the triples with the predicate equal to owl:sameAs.\n        Returns:\n            int: A integer that is the number of sameAs chains.\n        \"\"\"\ntry:\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\nnumSameAs = q.getSameAsChains(url)\nelse:\nnumSameAs = 'SPARQL endpoint absent'\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nnumSameAs = 'SPARQL endpoint offline'\nexcept Exception as e:\nnumSameAs = e\nreturn numSameAs\ndef getExternalProvider(self):\n\"\"\"\n        Return a dict with all external provider the key is the id of the KG it is connected to and the value is the number of triples connected, this information is obtained by analyzing the metadata.\n        Returns:\n            dict: A dict with all external provider.\n        \"\"\"\nextLinks = aggregator.getExternalLinks(self.id)\nreturn extLinks\n#SECURITY\ndef checkAuth(self):\n\"\"\"\n        Check if authentication is required to do SPARQL query on the endpoint.\n        Returns:\n            bool: A boolean that is True if authentication is required, False otherwise.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nq.checkEndPoint(url)\nreturn False\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed):\nreturn 'SPARQL endpoint offline'\nexcept SPARQLExceptions.Unauthorized:\nreturn True\nelse:\nreturn 'SPARQL endpoint absent'\ndef checkHTTPS(self):\n\"\"\"\n        Check if data exchange on the SPARQL endpoint takes place on HTTPS protocol.\n        Returns:\n            bool: A boolean that is True if HTTPS is used, Flase otherwise.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nisSecure = utils.checkhttps(url)\nif isSecure == True or isinstance(isSecure,list): #IF QUERY ON THE SPARQL ENDPOINT RETURN A RESULT IT IS A LIST, SO URL WITH HTTPS WORKS \nreturn True\nelse:\nreturn False\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept:\nreturn False\nelse:\nreturn 'SPARQL endpoint absent'\n#PERFORMANCE\ndef getLatency(self):\n\"\"\"\n        Get the latency of the sparql endpoint, is the time passed between the request for a triple and when is returned.\n        The value returned is the average latency  of the 5 attempts performed.\n        Returns:\n            float: A float that is the average latency if SPARQL endpoint is online.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nlatency = q.testLatency(url)\nsumL = sum(latency)\naverage = sumL/len(latency)\nreturn average\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept Exception as e:\nreturn e\nelse:\nreturn 'SPARQL endpoint absent'\ndef getThroughput(self):\n\"\"\"\n        Get the throughput of the sparql endpoint, is the number of triples obtained by the endpoint in one second.\n        The value returned is the average thrpughput of the 5 attempts performed.\n        Returns:\n            float: A float that represent the throughput of the SPARQL endpoint.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\ntp = utils.getThroughput(url)\nsumTP = sum(tp)\naverage = sumTP/len(tp)\nreturn average\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept Exception as e:\nreturn e\nelse:\nreturn 'SPARQL endpoint absent'\n#ACCURACY\ndef checkEmptyLabel(self):\n\"\"\"\n        Count the number of empty label (if any) in the dataset.\n        Returns:\n            int: An integer that is the number of empty label is SPQRQL endpoint is online.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nlabels = q.getLabel(url)\nemptyL = 0\nfor label in labels:\nif utils.checkURI(label) == False:\nif label == '':\nemptyL = emptyL + 1\nreturn emptyL\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept Exception as e:\nreturn e\nelse:\nreturn 'SPARQL endpoint absent'\ndef checkWhiteSpace(self):\n\"\"\"\n        Count the number of label that have a whitespace at the beginning or at the end.\n        Returns:\n            int: An integer that is the number of label with whitespace problem if SPARQL endpoint is online.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nwsCount = 0\nlabels = q.getLabel(url)\nfor label in labels:\nif utils.checkURI(label) == False:\nif label != label.strip():\nwsCount = wsCount + 1\nreturn wsCount\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept Exception as e:\nreturn e\nelse:\nreturn 'SPARQL endpoint offline' \ndef checkDatatypeProblem(self):\n\"\"\"\n        Count the number of literal that do not match the data type indicated.\n        Returns:\n            int: A integer that is the number of literal with datatype problem.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\ndataTypeProblem = 0\ntriples = q.getAllTriplesSPO(url)\nif isinstance(triples,list):\nfor triple in triples:\nobj = triple.get('o')\nvalue = obj.get('value')\nif utils.checkURI(value) == False:\ndataType = obj.get('datatype')\nif isinstance(dataType,str):\nregex = utils.getRegex(dataType)\nif regex is not None:\nresult = utils.checkString(regex,value)\nif result == False:\ndataTypeProblem = dataTypeProblem + 1\nreturn dataTypeProblem\nelse:\nreturn \"Can't recover triples from the endpoint\"\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept Exception as e:\nreturn e\nelse:\nreturn 'SPARQL endpoint absent'\ndef checkFPViolations(self):\n\"\"\"\n        Check for functional properties with inconsistent value, analyzing all triples with predicate owl:FunctionalProperty and checking if there is any violations.\n        Returns:\n            int: An integer that is the number of triples with functional property violations.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nviolationFP = []\ntriplesFP = q.getFP(url)\nfor triple in triplesFP:\ns = triple.get('s')\nsubject1 = s.get('value')\no = triple.get('o')\nobj1 = o.get('value')\nfor triple2 in triplesFP:\ns = triple2.get('s')\nsubject2 = s.get('value')\no = triple2.get('o')\nobj2 = o.get('value')\nif subject1 == subject2 and obj1 != obj2:\nviolationFP.append(triple)\nreturn len(violationFP)\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept Exception as e:\nreturn e\nelse:\nreturn 'SPARQL endpoint absent'\ndef checkIFPViolations(self):\n\"\"\"\n        Check for invalid usage of inverse-functional properties, analyzing all triples with predicate owl:InverseFunctionalProperty and checking if there is any violations. \n        Returns:\n            int: An integer that is the number of triples with inverse-functional properties violations.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nviolationIFP = []\ntriplesIFP = q.getIFP(url)\nfor triple in triplesIFP:\ns = triple.get('s')\nsubject1 = s.get('value')\no = triple.get('o')\nobj1 = o.get('value')\nfor triple2 in triplesIFP:\ns = triple2.get('s')\nsubject2 = s.get('value')\no = triple2.get('o')\nobj2 = o.get('value')\nif obj1 == obj2 and subject1 != subject2:\nviolationIFP.append(triple)\nreturn len(violationIFP)\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept Exception as e:\nreturn e\nelse:\nreturn 'SPARQL endpoint absent'\n#CONSISTENCY    \ndef getDisjointValue(self):\n\"\"\"\n        Get the disjoint value. It is calculated by counting the number of triples with predicate owl:disjointWith and then making the ratio between number of triples with that predicate and number of entities.\n        Returns:\n            float: A float that represent the disjoint value if triples and entity is recovered correctly form SPARQL endpoint.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nnumDisjoint = q.getDisjoint(url)\nnumEntities = q.getNumEntities(url)\nif not isinstance(numEntities,int):\nregex = []\nregex = q.checkUriRegex(url)\npattern = q.checkUriPattern(url)\nfor p in pattern:\nnewRegex = utils.trasforrmToRegex(p)\nregex.append(newRegex)\nif len(regex) &gt; 0:\nnumEntities = 0\nfor r  in regex:\nnumEntities = numEntities + q.getNumEntitiesRegex(url,r)\nif isinstance(numDisjoint,int):\ntry:\nnumEntities = int(numEntities)\nif numEntities &gt; 0:\ndisjointValue = numDisjoint/numEntities\ndisjointValue = \"%.3f\"%disjointValue\ndisjointValue = float(disjointValue)\nelse:\ndisjointValue = 'insufficient data'\nexcept:\ndisjointValue = 'insufficient data'   \nreturn disjointValue     \nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'   \nexcept Exception as e:\nreturn e\nelse:\nreturn 'SPARQL endpoint absent'\ndef getUndefinedClass(self):\n\"\"\"\n        Get the classes used without declaration.\n        Returns:\n            list: A list that contains undefined classes\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nallTriples = q.getAllTriplesSPO(url)\nallType = q.getAllType(url)\ntoSearch = []\nfound = False\nfor i in range(len(allTriples)):\ns = allTriples[i].get('s')\ns = s.get('value')\nallType.sort()\nr = utils.binarySearch(allType,0,len(allType)-1,s)\nif r != -1:\nfound = True\nbreak\nif found == False:\nresult = utils.checkURI(s)\nif result == True:\ntoSearch.append(s)\nfound = False\nundClasses = LOVAPI.searchTermsList(toSearch)\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept Exception as e:\nreturn e\nreturn undClasses\nelse:\nreturn 'SPARQL endpoint absent'\ndef getUndefinedProp(self):\n\"\"\"\n        Get the properties used without declaration.\n        Returns:\n            list: A list that contains a list of undefined properties. \n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nuriListP = q.getAllPredicate(url)\nproperties = q.getAllProperty(url)\ntoSearch = []\nfound = False\nfor i in range(len(uriListP)):\np = uriListP[i]\nproperties.sort()\nr = utils.binarySearch(properties,0,len(properties)-1,p)\nif r != -1:\nfound = True\nbreak\nif found == False:\nresult = utils.checkURI(p)\nif result == True:\ntoSearch.append(p)\nfound = False\nundProperties = LOVAPI.searchTermsList(toSearch)\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nundProperties = 'SPARQL endpoint offline'\nexcept :\nundProperties = 'Could not process formulated query on indicated endpoint'\nreturn undProperties\nelse:\nreturn 'SPARQL endpoint absent'\ndef checkDeprecatedClassesProp(self):\n\"\"\"\n        Check if deprecated classes and properties are used in the KG.\n        Returns:\n            list: A list that contains  deprecated classes and properties used in the KG.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\ndeprecated = q.getDeprecated(url)\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept Exception as e:\ndeprecated = e\nreturn deprecated\nelse:\nreturn 'SPARQL endpoint absent'            \ndef checkOntologyHijacking(self):\n\"\"\"\n        Check for the ontology hijacking problem, if the SPARQL endpoint is online.\n        This problem is present if there are a re-definition of classes or properties considered standard for LOD.\n        Returns:\n            bool: A boolean that is True if there is a Ontology Hijacking problem, False otherwise.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nallType = q.getAllType(url)\ntriplesOH = False\nif isinstance(allType,list):\ntriplesOH = LOVAPI.searchTermsList(allType)\nif len(triplesOH) &gt; 0:\nhijacking = True\nelse:\nhijacking = False\nelse:\nhijacking = 'Impossible to retrieve the terms defined in the dataset'\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nhijacking = 'SPARQL endpoint offline'\nexcept:\nhijacking = 'Could not process formulated query on indicated endpoint'\nreturn hijacking\nelse:\nreturn 'SPARQL endpoint absent'\ndef checkMisplacedClasses(self):\n\"\"\"\n        Check if the classes are used incorrectly, classes are used in the position of the predicate.\n        Returns:\n            list: A list of misplaced classes.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nmisplacedClass = []\nproperties = q.getAllProperty(url)\nallTriples = q.getAllTriplesSPO(url)\nfound = False\nif isinstance(allTriples,list) and isinstance(properties,list):\nproperties.sort()\nfor i in range(len(allTriples)):\no = allTriples[i].get('o')\nvalueO = o.get('value')\ns = allTriples[i].get('s')\nvalueS = s.get('value')\nresult = utils.checkURI(valueS)\nif result == True:\nr = utils.binarySearch(properties,0,len(properties)-1,valueS)\nif r != -1:\nfound = True\nresultO = utils.checkURI(valueO)\nif found == False and resultO == True:\nr2 = utils.binarySearch(properties,0,len(properties)-1,valueO)\nif r2 != -1:\nfound = True\nif found == True:\nmisplacedClass.append(valueS)\nfound = False\nelse:\nmisplacedClass = 'insufficient data'\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nmisplacedClass = 'SPARQL endpoint offline'\nexcept TimeoutError:\nmisplacedClass = 'Timeout'\nexcept:\nmisplacedClass = 'Could not process formulated query on indicated endpoint'\nreturn misplacedClass\nelse:\nreturn 'SPARQL endpoint absent'\ndef checkMisplacedProperty(self):\n\"\"\"\n        Check if the properties are used incorrectly, properties are used in the position of the subject.\n        Returns:\n            list: A list of properties with misplaced propery problem.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nmisplacedProperty = []\nclasses = q.getAllClasses(url)\nuriListP = q.getAllPredicate(url)\nif isinstance(uriListP,list) and isinstance(classes,list):\nfor i in range(len(uriListP)):\np = uriListP[i]\nresult = utils.checkURI(p)\nif result == True:\nclasses.sort()\nr = utils.binarySearch(classes,0,len(classes)-1,p)\nif r != -1:\nmisplacedProperty.append(p)\nelse:\nmisplacedProperty = 'insufficient data'\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nmisplacedProperty =  'SPARQL endpoint offline'\nexcept Exception as e:\nmisplacedProperty = e\nreturn misplacedProperty\nelse:\nreturn 'SPARQL endpoint absent'\n#CONCISENESS\ndef getIntensionalConc(self):\n\"\"\"\n        Get the intensional conciseness value, it is calculated by the following formula: 1.0 - #duplicated properties (calculated with Bloom filter algorithm)/#triples in the dataset.\n        Returns:\n            float: A float that is the intensional conciseness value.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nallProperty = q.getAllPropertySP(url)\ntriplePropList = []\nduplicateP = []\nif isinstance(allProperty,list):\nif len(allProperty) &gt; 0:\nfor i in range(len(allProperty)):\ns = allProperty[i].get('s')\np = allProperty[i].get('p')\nsubP = s.get('value')\npredP = p.get('value')\ntripleProp = subP + predP\ntriplePropList.append(tripleProp)\nbloomF2 = BloomFilter(len(triplePropList),0.05)\nfor j in range(len(triplePropList)):\nfound = bloomF2.check(triplePropList[j])\nif found == False:\nbloomF2.add(triplePropList[j])\nelif found == True:\nduplicateP.append(triplePropList[j])\nif len(allProperty) &gt; 0:\nintC = 1.0 - (len(duplicateP)/len(allProperty))\nintC = \"%.3f\"%intC\nintC = float(intC)\nelse:\nintC = 'insufficient data'\nelse:\nintC = '0 properties retrieved from the endpoint'\nelse:\nintC = 'insufficient data'\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nintC = 'SPARQL endpoint offline'\nexcept:\nintC = 'Could not process formulated query on indicated endpoint'\nreturn intC\nelse:\nreturn 'SPARQL endpoint absent'\ndef getExtensionaConc(self):\n\"\"\"\n        Get the extensional conciseness value, it is calculated by the following formula: 1.0 - #duplicated triples (calculated with Bloom filter algorithm) / #triples in the dataset.\n        Returns:\n            float: A float that is the extensional conciseness value.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nallTriples = q.getAllTriplesSPO(url)\ntripleList = []\nduplicate = []\nif isinstance(allTriples,list):\nif len(allTriples)&gt; 0:    \nfor i in range(len(allTriples)):\ns = allTriples[i].get('s')\np = allTriples[i].get('p')\no = allTriples[i].get('o')\nsubject = s.get('value')\npredicate = p.get('value')\nobject = o.get('value')\ntriple = subject + predicate + object\ntripleList.append(triple)\nbloomF = BloomFilter(len(tripleList),0.05)\nprint(\"Size of bit array:{}\".format(bloomF.size))\nprint(\"False positive Probability:{}\".format(bloomF.fp_prob))\nprint(\"Number of hash functions:{}\".format(bloomF.hash_count))\nfor i in range(len(tripleList)):\nfound = bloomF.check(tripleList[i])\nif found == False:\nbloomF.add(tripleList[i])\nelif found == True:\nduplicate.append(tripleList[i])\nif len(allTriples) &gt; 0:\nexC = 1.0 - (len(duplicate)/len(allTriples)) # From: Evaluating the Quality of the LOD Cloud: An Empirical Investigation (Ruben Verborgh)\nexC = \"%.3f\"%exC\nexC = float(exC)\nelse:\nexC = 'insufficient data'\nelse:\nexC = '0 triples retrieved from the endpoint'\nelse:\nexC = 'insufficient data'\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nexC = 'SPARQL endpoint offline'\nexcept:\nexC = 'Could not process formulated query on indicated endpoint'\nreturn exC\nelse:\nreturn 'SPARQL endpoint absent'\n#REPUTATION\ndef getPageRank(self):\n\"\"\"\n        Get the pagerank of KG based on the graph constructed with all the kg discoverable.\n        Returns:\n            float: A float that represent the pagerank value.\n        \"\"\"\ngraph = utils.checkGraphFile()\npageRank = Graph.getPageRank(graph,self.id)\npageRank = \"%.4f\"%pageRank\nreturn float(pageRank)\n#BELIEVABILITY\ndef getName(self):\n\"\"\"\n        Get the title of the KG by analyzing the metadata.\n        Returns:\n            string: A string that contains the title of the KG.\n        \"\"\"\nmetadata = aggregator.getDataPackage(self.id)\ntitle = aggregator.getNameKG(metadata)\nreturn title\ndef getDescription(self):\n\"\"\"\n        Get the description of the KG by analyzing the metadata.\n        Returns:\n            string: A string that contains a description of the KG.  \n        \"\"\"\nmetadata = aggregator.getDataPackage(self.id)\ndescription = aggregator.getDescription(metadata)\nreturn description\ndef getUri(self):\n\"\"\"\n        Get the URI of the KG by analyzing the metadata.\n        Returns:\n            string: A tring that is the URI of the KG.\n        \"\"\"\nmetadata = aggregator.getDataPackage(self.id)\nsources = aggregator.getSource(metadata)\nurl = sources.get('web','Absent')\nreturn url\ndef calculateTrustValue(self):\n\"\"\"\n        Calculate the trust value of the KG. It is a value between -1 and 1, -1 when all believability data is absent, value beetween 0 and 1 based on how many values are present.\n        Returns:\n            int: A integer that is the trust value of the KG.\n        \"\"\"\nmetadata = aggregator.getDataPackage(self.id)\ntitle = aggregator.getNameKG(metadata)\ndescription = aggregator.getDescription(metadata)\nsources = aggregator.getSource(metadata)\nurl = sources.get('web','Absent')\n#CHECK IF THE KG IS IN A LIST OF RELIABLE PROVIDERS\ntry:\nproviders = ['wikipedia','government','bioportal','bio2RDF','academic']\nkeywords = aggregator.getKeywords(self.id)\nif any(x in keywords for x in providers):\nbelievable = True\nelse:\nbelievable = False\nexcept:\nbelievable = 'absent'\nvalueN = 0\nvalueD = 0\nvalueUrl = 0\nvaluePr = 0\nif isinstance(title,str):\nif title != '' and title != 'Absent' and title != 'absent':\nvalueN = 1\nif isinstance(description,str):\nif description != '' and description != False and description != 'Absent':\nvalueD = 1\nif isinstance(url,str):\nif url != '' and url !='Absent' and url != 'absent':\nvalueUrl = 1\nif believable == True:\nvaluePr = 1\nif valueN == 0 and valueD == 0 and valueUrl == 0 and valuePr == 0:\ntrustValue = -1\ntrustValue = (valueN+valueD+valueUrl+valuePr)/4\nreturn trustValue\n#VERIFIABILITY\ndef getVocabularies(self):\n\"\"\"\n        Get all the vocabularies used in the KG. This information is retrived from the SPARQL endpoint or VOID file.\n        Returns:\n            list: A list that contains all the vocabularies used in the KG.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\nvocabularies = q.getVocabularies(url)\nexcept:\nvocabularies = 'SPARQL endpoint offline'\nif not isinstance(voidFile,bool):  #IF SPARQL ENDPOINT IS OFFLINE TRY TO GET THE VOCABULARIES FROM VOID FILE\nvocabularies = VoIDAnalyses.getVocabularies(voidFile)\nelif not isinstance(voidFile,bool): #IF SPARQL ENDPOINT IS ABSENT TRY TO GET THE VOCABULARIES FROM VOID FILE\nvocabularies = VoIDAnalyses.getVocabularies(voidFile)\nelse:\nvocabularies = 'Impossible to retrieve vocabularies from SPARQL endopoint or VOID file'\nreturn vocabularies\ndef getAuthors(self):\n\"\"\"\n        Get all KG authors. This information is retrived from the SPARQL endpoint or VOID file.\n        Returns:\n            list: A list that contains all the authors of the KG.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\nauthors = q.getCreator(url)\nexcept:\nauthors = 'SPARQL endpoint offline'\nif not isinstance(voidFile,bool):\nauthors = VoIDAnalyses.getCreators(voidFile)\nelif not isinstance(voidFile,bool):\nauthors = VoIDAnalyses.getCreators(voidFile)\nelse:\nauthors = 'Impossible to retrieve vocabularies from SPARQL endopoint or VOID file'\nreturn authors\ndef getPublishers(self):\n\"\"\"\n        Get all the KG pubilshers. This information is retrived from the SPARQL endpoint or VOID file.\n        Returns:\n            list: A list that contains the publishers of the KG.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\npublishers = q.getPublisher(url)\nexcept:\npublishers = 'SPARQL endpoint offline'\nif not isinstance(voidFile,bool):\npublishers = VoIDAnalyses.getPublishers(voidFile)\nelif not isinstance(voidFile,bool):\npublishers = VoIDAnalyses.getPublishers(voidFile)\nelse:\npublishers = 'Impossible to retrieve vocabularies from SPARQL endopoint or VOID file'\nreturn publishers\ndef getContributors(self):\n\"\"\"\n        Get all the KG contributors. This information is retrived from the SPARQL endpoint or VOID file.\n        Returns:\n            list: A list that contains all the contributors to the KG.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\ncontributors = q.getContributors(url)\nexcept:\ncontributors = 'SPARQL endpoint offline'\nif not isinstance(voidFile,bool):\ncontributors = VoIDAnalyses.getContributors(voidFile)\nelif not isinstance(voidFile,bool):\ncontributors = VoIDAnalyses.getContributors(voidFile)\nelse:\ncontributors = 'Impossible to retrieve vocabularies from SPARQL endopoint or VOID file'\nreturn contributors\ndef getSources(self):\n\"\"\"\n        Get the KG sources. This return a Sources object that contains three field: web, email, name.\n        Returns:\n            Sources object: A Sources object that contain information about web address, email, name authors or maintainer.\n        \"\"\"\nmetadata = aggregator.getDataPackage(self.id)\nsources = aggregator.getSource(metadata)\nif sources == False:\nsourcesObj = Sources('Absent','Absent','Absent')\nelse:\nsourcesObj = Sources(sources.get('web','Absent'),sources.get('name','Absent'),sources.get('email','Absent'))\nreturn sourcesObj  #use sourcesKG() to print information about sources\ndef checkSign(self):\n\"\"\"\n        Check if the KG is signed.\n        Returns:\n            bool: A boolean that is True if is signed, False otherwise.l\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nsign = q.getSign(url)\nif isinstance(sign,int):\nif sign &gt; 0:\nsigned = True\nelse:\nsigned = False\nelse:\nsigned = False\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nsigned = 'SPARQL endpoint offline'\nexcept :\nsigned = 'Could not process formulated query on indicated endpoint'\nelse:\nsigned = 'SPARQL endpoint absent'\nreturn signed\n#CURRENCY\ndef getCreationDate(self):\n\"\"\"\n        Get the KG creation date. This information is retrived from the SPARQL endpoint or VOID file. False is returned if SPARQL endpoint is offline\n        Returns:\n            string: A string that is the KG creation date  \n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\ncreationD = q.getCreationDateMin(url)\nexcept:\ncreationD = False\ntry:\ncreationD = q.getCreationDate(url)\nexcept:\ncreationD = False\nif not isinstance(voidFile,bool) and not isinstance(creationD,str):\ncreationD = VoIDAnalyses.getCreationDate(voidFile)\nelif not isinstance(voidFile,bool):\ncreationD = VoIDAnalyses.getCreationDate(voidFile)\nelse:\ncreationD = 'SPARQL endpoint and VoID absent'\nreturn creationD\ndef getModificationDate(self):\n\"\"\"\n        Get the KG modification date. This information is retrived from SPARQL endpoint or VOID file. False is returned if SPARQL endpoint is offline.\n        Returns:\n            string: A string that contains a KG modification date.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\nmodificationD = q.getModificationDateMax(url)\nexcept:\nmodificationD = False\ntry:\nmodificationD = q.getModificationDate(url)\nexcept:\nmodificationD = False\nif not isinstance(voidFile,bool) and not isinstance(modificationD,str):\nmodificationD = VoIDAnalyses.getCreationDate(voidFile)\nelif not isinstance(voidFile,bool):\nmodificationD = VoIDAnalyses.getCreationDate(voidFile)\nelse:\nmodificationD = 'SPARQL endpoint and VoID absent'\nreturn modificationD\ndef getPercentageUpData(self,modificationDate):\n\"\"\"\n        Get the percentage of updated data. The percentage is calcualted based on the modificationDate given as a parameter.\n        Returns:\n            string: A percentage of updated data.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nnumTriplesUp = q.getNumUpdatedData(url,modificationDate)\nexcept:\nnumTriplesUp = 'SPARQL endpoint offline'\nelse:\nnumTriplesUp = 'SPARQL endpoint absent'\nreturn numTriplesUp\ndef getLastUp(self):\n\"\"\"\n        Get the elapsed time since the last modification (in days).\n        Returns:\n            string: A string that represent the days that have passed since the last modification.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\nmodificationD = q.getModificationDateMax(url)\nexcept:\nmodificationD = False\ntry:\nmodificationD = q.getModificationDate(url)\nexcept:\nmodificationD = False\nif not isinstance(voidFile,bool) and not isinstance(modificationD,str):\nmodificationD = VoIDAnalyses.getCreationDate(voidFile)\nelif not isinstance(voidFile,bool):\nmodificationD = VoIDAnalyses.getCreationDate(voidFile)\nelse:\nmodificationD = 'SPARQL endpoint and VoID absent'\ntry:\ntoday = datetime.date.today()\ntodayFormatted = today.strftime(\"%Y-%m-%d\")\ntodayDate =  datetime.datetime.strptime(todayFormatted, \"%Y-%m-%d\").date()\nmodificationD = datetime.datetime.strptime(modificationD, \"%Y-%m-%d\").date()\ndelta = (todayDate - modificationD).days\nexcept:\ndelta = 'Insufficient data'\nreturn delta\n#VOLATILITY\ndef getFrequencyUp(self):\n\"\"\"\n        Get the KG update frequency. This information is retrived from SPARQL endpoint or VOID file.\n        Returns:\n            string: A string that contains the KG update frequency.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\nfrequency = q.getFrequency(url)\nexcept:\nfrequency = 'SPARQL endpoint offline'\nif not isinstance(voidFile,bool):\nfrequency = VoIDAnalyses.getFrequency(voidFile)\nelif not isinstance(voidFile,bool):\nfrequency = VoIDAnalyses.getFrequency(voidFile)\nelse:\nfrequency = 'SPARQL endpoint and VoID file absent'\nreturn frequency\n#COMPLETENESS\ndef getInterlinkingComp(self):\n\"\"\"\n        Calcuate the interlinking completeness. It is calculated by the ratio between the number of linked triples and number of all triples in the dataset.\n        Returns:\n            int: An integer that is the interlinking completeness of the KG.\n        \"\"\"\nexternalLinks = aggregator.getExternalLinks(self.id)\nexLinksObj = utils.toObjectExternalLinks(externalLinks)\ntriplesL = 0\nfor i in range(len(exLinksObj)): #COUNTING THE NUMBER OF TRIPLES CROSS EXTERNAL LINK LIST IN THE METADATA\nlink = exLinksObj[i]\nvalue = link.value\nvalue = str(link.value)\nvalue = re.sub(\"[^\\d\\.]\", \"\",value) #CHECK IF THE VALUE IS A NUMBER\nvalue = int(value)\ntriplesL = triplesL + value\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\ntriples = q.getNumTripleQuery(url) #COUNT THE NUMBER OF TRIPLES WITH A SPARQL QUERY\nexcept:   #IF SPARQL ENDPOINT IS OFFLINE, COUNT THE TRIPLES BY ANALYZING THE METADATA\ntriples = 'SPARQL endpoint offline'\nmetadata = aggregator.getDataPackage(self.id)\ntriples = aggregator.getTriples(metadata)\nelse:\ntriples = 'SPARQL endpoint and VoID file absent'\ntry:\ntriplesL = int(triplesL)\ntriples = int(triples)\nif triples &gt; 0:\niCompl = (triplesL/triples)\niCompl = \"%.2f\"%iCompl\niCompl = float(iCompl)\nelse:\niCompl = 'Insufficient data'\nexcept:\niCompl = 'Insufficient data'\nreturn iCompl\n#AMOUNT OF DATA\ndef getNumTriples(self):\n\"\"\"\n        Get the number of triples in the KG. This information can be obtained by SPARQL endpoint or analyzing the metadata of the dataset.\n        Returns:\n            int: An integer that is the number of triples.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nmetadata = aggregator.getDataPackage(self.id)\nif isinstance(url,str):\ntry:\ntriples = q.getNumTripleQuery(url)\nexcept:\ntriples = 'SPARQL endpoint offline'\ntriples = aggregator.getTriples(metadata)\nelse:\ntriples = aggregator.getTriples(metadata)\nreturn triples\ndef getNumEntities(self):\n\"\"\"\n        Count the number of entities in the dataset. This information can be obtained by a SPARQL endpoint or analyzing the VoID file.\n        Returns:\n            int: An integer that is the number of entities in the KG.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\nentities = q.getNumEntities(url)\ntry:\nentities = int(entities)\nreturn entities\nexcept:  #IF WITH THE FIRST QUERY WE DON'T GET THE RESULT, WE TRY TO COUNT THE NUMBER OF ENTITIES BY COUNTING THE NUMBER OF TRIPLES THAT MATH WITH THEKG URI REGEX\n#GET THE REGEX OF THE URLs USED\nregex = []\ntry:\nregex = q.checkUriRegex(url)\nexcept:\nregex = 'Could not process formulated query on indicated enpdoint'\n#CHECK IF IS INDICATED A URI SPACE INSTEAD OF A REGEX AND WE TRAFORM IT TO REGEX\ntry:    \npattern = q.checkUriPattern(url)  \nif isinstance(pattern,list):\nfor i in range(len(pattern)): \nnewRegex = utils.trasforrmToRegex(pattern[i])\nregex.append(newRegex)\nexcept:\npattern = 'Could not process formulated query on indicated enpdoint'\n#NOW COUNT THE ENITITIES USING THE REGEX\ntry:\nif len(regex) &gt; 0:\nentities = 0\nfor i in range(len(regex)):\nentities = entities + q.getNumEntitiesRegex(url,regex[i])\nelse:\nentities = 'insufficient data'\nexcept Exception as e:\nentities = e\nreturn entities\nexcept:\nif not isinstance(voidFile,bool):\nentities = VoIDAnalyses.getNumEntities(voidFile)\nreturn entities\nelif not isinstance(voidFile,bool):\nentities = VoIDAnalyses.getNumEntities(voidFile)\nreturn entities\nelse:\nreturn 'SPARQL endpoint and VoID file absent'\ndef getNumProperty(self):\n\"\"\"\n        Get the number of property in the KG. This information is retrived by executing a query on the SPARQL endpoint.\n        Returns:\n            int: An integer that is the number of properties in the KG.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nnumProperty = q.numberOfProperty(url)\nexcept:\nnumProperty = 'SPARQL endpoint offline'\nelse:\nnumProperty = 'SPARQL endpoint absent'\nreturn numProperty\n#REPRESENTATIONAL-CONCISENESS\ndef getUriLenghtSub(self):\n\"\"\"\n        Get the uri's length in the subject position. The returned value is a list in which the values are respectively min-max-average-standard deviation.\n        Returns:\n            list: A list that contains all the URI in the KG.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nlengthtList = []\ntriples = q.getAllTriplesSPO(url)\nfor triple in triples:\ns = triple.get('s')\nuri = s.get('value')\nif utils.checkURI(uri) == True:\nlengthtList.append(len(uri))\nsumLenghts = sum(lengthtList)\navLenghts = sumLenghts/len(lengthtList) \navLenghts = str(avLenghts)\navLenghts = avLenghts.replace('.',',')\nstandardDeviationL = numpy.std(lengthtList)\nstandardDeviationL = str(standardDeviationL)\nstandardDeviationL = standardDeviationL.replace('.',',')\nminLenghtS = min(lengthtList)\nmaxLenghtS = max(lengthtList)\nlength = [minLenghtS,maxLenghtS,avLenghts,standardDeviationL]\nexcept:\nlength = 'SPARQL endpoint offline'\nelse:\nlength = 'SPARQL endpoint absent'\nreturn length\ndef getUriLenghtObj(self):\n\"\"\"\n        Get the uri's length in the object position. The returned value is a list in which the values are respectively min-max-average-standard deviation.\n        Returns:\n            list: A list that contains all the URI in the object position\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nuriListO = q.getAllObject(url)\nlengthtList = []\nfor triple in uriListO:\nif utils.checkURI(triple) == True:\nlengthtList.append(len(triple))\nsumLenghts = sum(lengthtList)\navLenghts = sumLenghts/len(lengthtList) \navLenghts = str(avLenghts)\navLenghts = avLenghts.replace('.',',')\nstandardDeviationL = numpy.std(lengthtList)\nstandardDeviationL = str(standardDeviationL)\nstandardDeviationL = standardDeviationL.replace('.',',')\nminLenghtS = min(lengthtList)\nmaxLenghtS = max(lengthtList)\nlength = [minLenghtS,maxLenghtS,avLenghts,standardDeviationL]\nexcept:\nlength = 'SPARQL endpoint offline'\nelse:\nlength = 'SPARQL endpoint absent'\nreturn length\ndef getUriLenghtPr(self):\n\"\"\"\n        Get the uri's length in the predicate position. The returned value is a list in which the values are respectively min-max-average-standard deviation.\n        Returns:\n            list: A list that contains URIs in the predicate position.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nuriListP = q.getAllPredicate(url)\nlengthtList = []\nfor triple in uriListP:\nif utils.checkURI(triple) == True:\nlengthtList.append(len(triple))\nsumLenghts = sum(lengthtList)\navLenghts = sumLenghts/len(lengthtList) \navLenghts = str(avLenghts)\navLenghts = avLenghts.replace('.',',')\nstandardDeviationL = numpy.std(lengthtList)\nstandardDeviationL = str(standardDeviationL)\nstandardDeviationL = standardDeviationL.replace('.',',')\nminLenghtS = min(lengthtList)\nmaxLenghtS = max(lengthtList)\nlength = [minLenghtS,maxLenghtS,avLenghts,standardDeviationL]\nexcept:\nlength = 'SPARQL endpoint offline'\nelse:\nlength = 'SPARQL endpoint absent'\nreturn length\ndef checkRDFStr(self):\n\"\"\"\n        Check if RDF data structures is used in the KG. \n        Returns:\n            bool: A boolean that is True if are used, False otherwise.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nrdf = q.checkRDFDataStructures(url)\nexcept:\nrdf = 'SPARQL endpoint offline'\nelse:\nrdf = 'SPARQL endpoint absent'\nreturn rdf\n#REPRESENTATIONAL-CONSISTENCY\ndef checkReuseTerms(self):\n\"\"\"\n        Check usage of existing terms. This check is done using the Linked Open Vocabulary, a KG that contains vocabulary and terms standard for Linked Open Data.\n        Returns:\n            bool: A boolean that is True if no new terms are defined, False otherwise.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nobjList = []\ntriplesO = q.getAllTypeO(url)\nfor term in triplesO:\nobjList.append(term)\nnewTermsD = LOVAPI.searchTermsList(objList)\nif len(newTermsD) &gt; 0:\nreturn False\nelse:\nreturn True\nexcept:\nreturn 'SPARQL endpoint offline'\nelse:\nreturn 'SPARQL endpoint absent'\ndef checkReuseVocabs(self):\n\"\"\"\n        Check usage of existing vocabularies. This check is done using the Linked Open Vocabulary, a KG that contains vocabularies and terms standard for Linked Open Data.\n        Returns:\n            bool: A boolean that is True if no new vocabularies are defined, False otherwise.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nnewVocab = []\nvocabs = q.getVocabularies(url)\nif isinstance(vocabs,list):\nfor vocab in vocabs:\nresult = LOVAPI.findVocabulary(vocab)\nif result == False:\nnewVocab.append(vocab)\nif len(newVocab) &gt; 0:\nreturn False\nelse:\nreturn True\nelse:\nreturn 'Impossible to retrieve KG vocabularies'\nexcept:\nreturn 'SPARQL endpoint offline'\nelse:\nreturn 'SPARQL endpoint absent'\n#UNDERSTENDABILITY\ndef getNumLabels(self):\n\"\"\"\n        Count the number of label on the triples in the KG. This count is done by using a query on the SPARQL endpoint.\n        Returns:\n            int: An integer that is the number of label in the KG.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nnumLabel = q.getNumLabel(url)\nexcept:\nnumLabel = 'SPARQL endpoint offline'\nelse:\nnumLabel = 'SPARQL endpoint absent'\nreturn numLabel\ndef getRegex(self):\n\"\"\"\n        Return the uri regex of the KG. This check id done by using a query on the SPARQL endpoin or by analyzing the VoID file if available.\n        Returns:\n            list: A list with the URI regex\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\nregex = []\ntry:\nregex = q.checkUriRegex(url)\nexcept Exception as e:\nregex = 'SPARQL endpoint offline'\nif not isinstance(voidFile,bool):\nregex = VoIDAnalyses.getUriRegex(voidFile) \n#CHECK IF IS INDICATED A URI SPACE INSTEAD OF A REGEX AND WE TRAFORM IT TO REGEX\ntry:    \npattern = q.checkUriPattern(url)  \nif isinstance(pattern,list):\nfor i in range(len(pattern)): \nnewRegex = utils.trasforrmToRegex(pattern[i])\nregex.append(newRegex)\nexcept:\npattern = 'SPARQL endpoint offline'\nelif not isinstance(voidFile,bool):\nregex = VoIDAnalyses.getUriRegex(voidFile)\nelse:\nregex = 'SPARQL endpint absent'\nreturn regex\ndef checkExample(self):\n\"\"\"\n        Check if query examples are provided with the KG. This information is obtained by analyzing the KG metadata, in particular, the field other resources.\n        Returns:\n            bool: A boolean that is True if there are any query examples , False otherwise.\n        \"\"\"\nresources = aggregator.getOtherResources(self.id)\nresources = utils.insertAvailability(resources)\notResources = utils.toObjectResources(resources)\nexample = False\nfor j in range(len(otResources)):\nif isinstance(otResources[j].format,str):\nif 'example' in otResources[j].format:\nexample = True\nif isinstance(otResources[j].title,str):\nif 'example' in otResources[j].title:\nexample = True\nreturn example\n#INTERPRETABILITY\ndef getNumbBN(self):\n\"\"\"\n        Get the blank node number. This is obtained by querying the SPARQL endpoint.\n        Returns:    \n            int: An integer that represent the number of blank node in the KG.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nnumBlankN = q.numBlankNode(url)\nexcept:\nnumBlankN = 'SPARQL endpoint offline'\nelse:\nnumBlankN = 'SPARQL endpoint absent'\nreturn numBlankN\n#VERSATILIY\ndef getSerializationFormat(self):\n\"\"\"\n        Get the KG serialization formats. This information is retrived by executing a query on the SPARQL endpoint or from VoID file if available.\n        Returns:\n            list: A list that contains all the serialization formats supported by the KG.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\nformats = q.checkSerialisationFormat(url)\nexcept:\nformats = 'SPARQL endpoint offline'\nif not isinstance(voidFile,bool):\nformats = VoIDAnalyses.getSerializationFormats(voidFile)\nelif not isinstance(voidFile,bool):\nformats = VoIDAnalyses.getSerializationFormats(voidFile)\nelse:\nformats = 'SPARQL endpoint and VoID file absent'\nreturn formats\ndef getLanguages(self):\n\"\"\"\n        Get the languages supported by the KG. This information is retrieved by querying the SPARQL endpoint.\n        Returns:\n            list: A list with all the languages supprted by the KG.\n        \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nlanguages = q.getLangugeSupported(url)\nexcept:\nlanguages = 'SPARQL endpoint offline'\nelse:\nlanguages = 'SPARQL endpoint absent'\nreturn languages\ndef getAccessAtKG(self):\n\"\"\"\n        Get the ways in which you can access the KG. This information is retrived by analyzing the metadata and/or querying the SPARQL endpoint.\n        Returns:\n            list: A list with all the links to access to the KG.\n        \"\"\"\nlinks = []\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nresources = aggregator.getOtherResources(self.id)\nresources = utils.insertAvailability(resources)\nlinks = links + utils.getLinkDownload(resources)\nif isinstance(url,str):\nlinks.append(url)\ntry:\nurlList = q.checkDataDump(url)\nif isinstance(urlList,list):\nactiveUrl = utils.getActiveDumps(urlList)\nlinks = links + activeUrl\nexcept:\npass\nelif not isinstance(voidFile,bool):\nlinks = links + VoIDAnalyses.getDataDump(voidFile)\nlinks = list(dict.fromkeys(links)) #REMOVE DUPLICATES IN THE LIST\nreturn links\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.calculateTrustValue","title":"<code>calculateTrustValue()</code>","text":"<p>Calculate the trust value of the KG. It is a value between -1 and 1, -1 when all believability data is absent, value beetween 0 and 1 based on how many values are present.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>A integer that is the trust value of the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def calculateTrustValue(self):\n\"\"\"\n    Calculate the trust value of the KG. It is a value between -1 and 1, -1 when all believability data is absent, value beetween 0 and 1 based on how many values are present.\n    Returns:\n        int: A integer that is the trust value of the KG.\n    \"\"\"\nmetadata = aggregator.getDataPackage(self.id)\ntitle = aggregator.getNameKG(metadata)\ndescription = aggregator.getDescription(metadata)\nsources = aggregator.getSource(metadata)\nurl = sources.get('web','Absent')\n#CHECK IF THE KG IS IN A LIST OF RELIABLE PROVIDERS\ntry:\nproviders = ['wikipedia','government','bioportal','bio2RDF','academic']\nkeywords = aggregator.getKeywords(self.id)\nif any(x in keywords for x in providers):\nbelievable = True\nelse:\nbelievable = False\nexcept:\nbelievable = 'absent'\nvalueN = 0\nvalueD = 0\nvalueUrl = 0\nvaluePr = 0\nif isinstance(title,str):\nif title != '' and title != 'Absent' and title != 'absent':\nvalueN = 1\nif isinstance(description,str):\nif description != '' and description != False and description != 'Absent':\nvalueD = 1\nif isinstance(url,str):\nif url != '' and url !='Absent' and url != 'absent':\nvalueUrl = 1\nif believable == True:\nvaluePr = 1\nif valueN == 0 and valueD == 0 and valueUrl == 0 and valuePr == 0:\ntrustValue = -1\ntrustValue = (valueN+valueD+valueUrl+valuePr)/4\nreturn trustValue\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkAuth","title":"<code>checkAuth()</code>","text":"<p>Check if authentication is required to do SPARQL query on the endpoint.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>A boolean that is True if authentication is required, False otherwise.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkAuth(self):\n\"\"\"\n    Check if authentication is required to do SPARQL query on the endpoint.\n    Returns:\n        bool: A boolean that is True if authentication is required, False otherwise.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nq.checkEndPoint(url)\nreturn False\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed):\nreturn 'SPARQL endpoint offline'\nexcept SPARQLExceptions.Unauthorized:\nreturn True\nelse:\nreturn 'SPARQL endpoint absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkDatatypeProblem","title":"<code>checkDatatypeProblem()</code>","text":"<p>Count the number of literal that do not match the data type indicated.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>A integer that is the number of literal with datatype problem.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkDatatypeProblem(self):\n\"\"\"\n    Count the number of literal that do not match the data type indicated.\n    Returns:\n        int: A integer that is the number of literal with datatype problem.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\ndataTypeProblem = 0\ntriples = q.getAllTriplesSPO(url)\nif isinstance(triples,list):\nfor triple in triples:\nobj = triple.get('o')\nvalue = obj.get('value')\nif utils.checkURI(value) == False:\ndataType = obj.get('datatype')\nif isinstance(dataType,str):\nregex = utils.getRegex(dataType)\nif regex is not None:\nresult = utils.checkString(regex,value)\nif result == False:\ndataTypeProblem = dataTypeProblem + 1\nreturn dataTypeProblem\nelse:\nreturn \"Can't recover triples from the endpoint\"\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept Exception as e:\nreturn e\nelse:\nreturn 'SPARQL endpoint absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkDeprecatedClassesProp","title":"<code>checkDeprecatedClassesProp()</code>","text":"<p>Check if deprecated classes and properties are used in the KG.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains  deprecated classes and properties used in the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkDeprecatedClassesProp(self):\n\"\"\"\n    Check if deprecated classes and properties are used in the KG.\n    Returns:\n        list: A list that contains  deprecated classes and properties used in the KG.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\ndeprecated = q.getDeprecated(url)\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept Exception as e:\ndeprecated = e\nreturn deprecated\nelse:\nreturn 'SPARQL endpoint absent'            \n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkDownload","title":"<code>checkDownload()</code>","text":"<p>Check if the link for download the KG as rdf dump is present and online.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>A boolean that represent the dump link availability (True = Online and False = Offline).</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkDownload(self):\n\"\"\"\n    Check if the link for download the KG as rdf dump is present and online.\n    Returns:\n        bool: A boolean that represent the dump link availability (True = Online and False = Offline). \n    \"\"\"\nresources = aggregator.getOtherResources(self.id)\nresources = utils.insertAvailability(resources)\navailable = utils.checkAvailabilityForDownload(resources)\nreturn available\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkEmptyLabel","title":"<code>checkEmptyLabel()</code>","text":"<p>Count the number of empty label (if any) in the dataset.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>An integer that is the number of empty label is SPQRQL endpoint is online.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkEmptyLabel(self):\n\"\"\"\n    Count the number of empty label (if any) in the dataset.\n    Returns:\n        int: An integer that is the number of empty label is SPQRQL endpoint is online.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nlabels = q.getLabel(url)\nemptyL = 0\nfor label in labels:\nif utils.checkURI(label) == False:\nif label == '':\nemptyL = emptyL + 1\nreturn emptyL\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept Exception as e:\nreturn e\nelse:\nreturn 'SPARQL endpoint absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkEndpointAv","title":"<code>checkEndpointAv()</code>","text":"<p>Check the SPARQL endpoint availability.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>A boolean that represent the SPARQL endpoint availability (True = Online and False = Offline).</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkEndpointAv(self):\n\"\"\"Check the SPARQL endpoint availability.\n    Returns:\n        bool: A boolean that represent the SPARQL endpoint availability (True = Online and False = Offline).\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\ntry:\nresult = q.checkEndPoint(url)\nif isinstance(result,bytes):\nnewUrl = utils.checkRedirect(url)\nresult = q.checkEndPoint(newUrl)\nif isinstance(result,bytes):\navailable = False\nelse:\navailable = True\nelse:\navailable = True\nexcept:\navailable = False\nreturn available\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkExample","title":"<code>checkExample()</code>","text":"<p>Check if query examples are provided with the KG. This information is obtained by analyzing the KG metadata, in particular, the field other resources.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>A boolean that is True if there are any query examples , False otherwise.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkExample(self):\n\"\"\"\n    Check if query examples are provided with the KG. This information is obtained by analyzing the KG metadata, in particular, the field other resources.\n    Returns:\n        bool: A boolean that is True if there are any query examples , False otherwise.\n    \"\"\"\nresources = aggregator.getOtherResources(self.id)\nresources = utils.insertAvailability(resources)\notResources = utils.toObjectResources(resources)\nexample = False\nfor j in range(len(otResources)):\nif isinstance(otResources[j].format,str):\nif 'example' in otResources[j].format:\nexample = True\nif isinstance(otResources[j].title,str):\nif 'example' in otResources[j].title:\nexample = True\nreturn example\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkFPViolations","title":"<code>checkFPViolations()</code>","text":"<p>Check for functional properties with inconsistent value, analyzing all triples with predicate owl:FunctionalProperty and checking if there is any violations.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>An integer that is the number of triples with functional property violations.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkFPViolations(self):\n\"\"\"\n    Check for functional properties with inconsistent value, analyzing all triples with predicate owl:FunctionalProperty and checking if there is any violations.\n    Returns:\n        int: An integer that is the number of triples with functional property violations.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nviolationFP = []\ntriplesFP = q.getFP(url)\nfor triple in triplesFP:\ns = triple.get('s')\nsubject1 = s.get('value')\no = triple.get('o')\nobj1 = o.get('value')\nfor triple2 in triplesFP:\ns = triple2.get('s')\nsubject2 = s.get('value')\no = triple2.get('o')\nobj2 = o.get('value')\nif subject1 == subject2 and obj1 != obj2:\nviolationFP.append(triple)\nreturn len(violationFP)\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept Exception as e:\nreturn e\nelse:\nreturn 'SPARQL endpoint absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkHTTPS","title":"<code>checkHTTPS()</code>","text":"<p>Check if data exchange on the SPARQL endpoint takes place on HTTPS protocol.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>A boolean that is True if HTTPS is used, Flase otherwise.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkHTTPS(self):\n\"\"\"\n    Check if data exchange on the SPARQL endpoint takes place on HTTPS protocol.\n    Returns:\n        bool: A boolean that is True if HTTPS is used, Flase otherwise.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nisSecure = utils.checkhttps(url)\nif isSecure == True or isinstance(isSecure,list): #IF QUERY ON THE SPARQL ENDPOINT RETURN A RESULT IT IS A LIST, SO URL WITH HTTPS WORKS \nreturn True\nelse:\nreturn False\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept:\nreturn False\nelse:\nreturn 'SPARQL endpoint absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkIFPViolations","title":"<code>checkIFPViolations()</code>","text":"<p>Check for invalid usage of inverse-functional properties, analyzing all triples with predicate owl:InverseFunctionalProperty and checking if there is any violations. </p> <p>Returns:</p> Name Type Description <code>int</code> <p>An integer that is the number of triples with inverse-functional properties violations.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkIFPViolations(self):\n\"\"\"\n    Check for invalid usage of inverse-functional properties, analyzing all triples with predicate owl:InverseFunctionalProperty and checking if there is any violations. \n    Returns:\n        int: An integer that is the number of triples with inverse-functional properties violations.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nviolationIFP = []\ntriplesIFP = q.getIFP(url)\nfor triple in triplesIFP:\ns = triple.get('s')\nsubject1 = s.get('value')\no = triple.get('o')\nobj1 = o.get('value')\nfor triple2 in triplesIFP:\ns = triple2.get('s')\nsubject2 = s.get('value')\no = triple2.get('o')\nobj2 = o.get('value')\nif obj1 == obj2 and subject1 != subject2:\nviolationIFP.append(triple)\nreturn len(violationIFP)\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept Exception as e:\nreturn e\nelse:\nreturn 'SPARQL endpoint absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkInactiveLinks","title":"<code>checkInactiveLinks()</code>","text":"<p>Check if there are inactive link associated with the KG.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>A boolean that represent if there are any inactive links associeted with the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkInactiveLinks(self):\n\"\"\"\n    Check if there are inactive link associated with the KG.\n    Returns:\n        bool: A boolean that represent if there are any inactive links associeted with the KG.\n    \"\"\"\nresources = aggregator.getOtherResources(self.id)\nresources = utils.insertAvailability(resources)\nresourcesObj = utils.toObjectResources(resources)\ninactiveLink = False\nfor link in resourcesObj:\nif link.status == 'offline':\ninactiveLink = True\nreturn inactiveLink\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkMisplacedClasses","title":"<code>checkMisplacedClasses()</code>","text":"<p>Check if the classes are used incorrectly, classes are used in the position of the predicate.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of misplaced classes.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkMisplacedClasses(self):\n\"\"\"\n    Check if the classes are used incorrectly, classes are used in the position of the predicate.\n    Returns:\n        list: A list of misplaced classes.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nmisplacedClass = []\nproperties = q.getAllProperty(url)\nallTriples = q.getAllTriplesSPO(url)\nfound = False\nif isinstance(allTriples,list) and isinstance(properties,list):\nproperties.sort()\nfor i in range(len(allTriples)):\no = allTriples[i].get('o')\nvalueO = o.get('value')\ns = allTriples[i].get('s')\nvalueS = s.get('value')\nresult = utils.checkURI(valueS)\nif result == True:\nr = utils.binarySearch(properties,0,len(properties)-1,valueS)\nif r != -1:\nfound = True\nresultO = utils.checkURI(valueO)\nif found == False and resultO == True:\nr2 = utils.binarySearch(properties,0,len(properties)-1,valueO)\nif r2 != -1:\nfound = True\nif found == True:\nmisplacedClass.append(valueS)\nfound = False\nelse:\nmisplacedClass = 'insufficient data'\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nmisplacedClass = 'SPARQL endpoint offline'\nexcept TimeoutError:\nmisplacedClass = 'Timeout'\nexcept:\nmisplacedClass = 'Could not process formulated query on indicated endpoint'\nreturn misplacedClass\nelse:\nreturn 'SPARQL endpoint absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkMisplacedProperty","title":"<code>checkMisplacedProperty()</code>","text":"<p>Check if the properties are used incorrectly, properties are used in the position of the subject.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of properties with misplaced propery problem.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkMisplacedProperty(self):\n\"\"\"\n    Check if the properties are used incorrectly, properties are used in the position of the subject.\n    Returns:\n        list: A list of properties with misplaced propery problem.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nmisplacedProperty = []\nclasses = q.getAllClasses(url)\nuriListP = q.getAllPredicate(url)\nif isinstance(uriListP,list) and isinstance(classes,list):\nfor i in range(len(uriListP)):\np = uriListP[i]\nresult = utils.checkURI(p)\nif result == True:\nclasses.sort()\nr = utils.binarySearch(classes,0,len(classes)-1,p)\nif r != -1:\nmisplacedProperty.append(p)\nelse:\nmisplacedProperty = 'insufficient data'\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nmisplacedProperty =  'SPARQL endpoint offline'\nexcept Exception as e:\nmisplacedProperty = e\nreturn misplacedProperty\nelse:\nreturn 'SPARQL endpoint absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkOntologyHijacking","title":"<code>checkOntologyHijacking()</code>","text":"<p>Check for the ontology hijacking problem, if the SPARQL endpoint is online. This problem is present if there are a re-definition of classes or properties considered standard for LOD.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>A boolean that is True if there is a Ontology Hijacking problem, False otherwise.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkOntologyHijacking(self):\n\"\"\"\n    Check for the ontology hijacking problem, if the SPARQL endpoint is online.\n    This problem is present if there are a re-definition of classes or properties considered standard for LOD.\n    Returns:\n        bool: A boolean that is True if there is a Ontology Hijacking problem, False otherwise.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nallType = q.getAllType(url)\ntriplesOH = False\nif isinstance(allType,list):\ntriplesOH = LOVAPI.searchTermsList(allType)\nif len(triplesOH) &gt; 0:\nhijacking = True\nelse:\nhijacking = False\nelse:\nhijacking = 'Impossible to retrieve the terms defined in the dataset'\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nhijacking = 'SPARQL endpoint offline'\nexcept:\nhijacking = 'Could not process formulated query on indicated endpoint'\nreturn hijacking\nelse:\nreturn 'SPARQL endpoint absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkRDFStr","title":"<code>checkRDFStr()</code>","text":"<p>Check if RDF data structures is used in the KG. </p> <p>Returns:</p> Name Type Description <code>bool</code> <p>A boolean that is True if are used, False otherwise.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkRDFStr(self):\n\"\"\"\n    Check if RDF data structures is used in the KG. \n    Returns:\n        bool: A boolean that is True if are used, False otherwise.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nrdf = q.checkRDFDataStructures(url)\nexcept:\nrdf = 'SPARQL endpoint offline'\nelse:\nrdf = 'SPARQL endpoint absent'\nreturn rdf\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkReuseTerms","title":"<code>checkReuseTerms()</code>","text":"<p>Check usage of existing terms. This check is done using the Linked Open Vocabulary, a KG that contains vocabulary and terms standard for Linked Open Data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>A boolean that is True if no new terms are defined, False otherwise.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkReuseTerms(self):\n\"\"\"\n    Check usage of existing terms. This check is done using the Linked Open Vocabulary, a KG that contains vocabulary and terms standard for Linked Open Data.\n    Returns:\n        bool: A boolean that is True if no new terms are defined, False otherwise.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nobjList = []\ntriplesO = q.getAllTypeO(url)\nfor term in triplesO:\nobjList.append(term)\nnewTermsD = LOVAPI.searchTermsList(objList)\nif len(newTermsD) &gt; 0:\nreturn False\nelse:\nreturn True\nexcept:\nreturn 'SPARQL endpoint offline'\nelse:\nreturn 'SPARQL endpoint absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkReuseVocabs","title":"<code>checkReuseVocabs()</code>","text":"<p>Check usage of existing vocabularies. This check is done using the Linked Open Vocabulary, a KG that contains vocabularies and terms standard for Linked Open Data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>A boolean that is True if no new vocabularies are defined, False otherwise.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkReuseVocabs(self):\n\"\"\"\n    Check usage of existing vocabularies. This check is done using the Linked Open Vocabulary, a KG that contains vocabularies and terms standard for Linked Open Data.\n    Returns:\n        bool: A boolean that is True if no new vocabularies are defined, False otherwise.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nnewVocab = []\nvocabs = q.getVocabularies(url)\nif isinstance(vocabs,list):\nfor vocab in vocabs:\nresult = LOVAPI.findVocabulary(vocab)\nif result == False:\nnewVocab.append(vocab)\nif len(newVocab) &gt; 0:\nreturn False\nelse:\nreturn True\nelse:\nreturn 'Impossible to retrieve KG vocabularies'\nexcept:\nreturn 'SPARQL endpoint offline'\nelse:\nreturn 'SPARQL endpoint absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkSign","title":"<code>checkSign()</code>","text":"<p>Check if the KG is signed.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>A boolean that is True if is signed, False otherwise.l</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkSign(self):\n\"\"\"\n    Check if the KG is signed.\n    Returns:\n        bool: A boolean that is True if is signed, False otherwise.l\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nsign = q.getSign(url)\nif isinstance(sign,int):\nif sign &gt; 0:\nsigned = True\nelse:\nsigned = False\nelse:\nsigned = False\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nsigned = 'SPARQL endpoint offline'\nexcept :\nsigned = 'Could not process formulated query on indicated endpoint'\nelse:\nsigned = 'SPARQL endpoint absent'\nreturn signed\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.checkWhiteSpace","title":"<code>checkWhiteSpace()</code>","text":"<p>Count the number of label that have a whitespace at the beginning or at the end.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>An integer that is the number of label with whitespace problem if SPARQL endpoint is online.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def checkWhiteSpace(self):\n\"\"\"\n    Count the number of label that have a whitespace at the beginning or at the end.\n    Returns:\n        int: An integer that is the number of label with whitespace problem if SPARQL endpoint is online.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nwsCount = 0\nlabels = q.getLabel(url)\nfor label in labels:\nif utils.checkURI(label) == False:\nif label != label.strip():\nwsCount = wsCount + 1\nreturn wsCount\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept Exception as e:\nreturn e\nelse:\nreturn 'SPARQL endpoint offline' \n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getAccessAtKG","title":"<code>getAccessAtKG()</code>","text":"<p>Get the ways in which you can access the KG. This information is retrived by analyzing the metadata and/or querying the SPARQL endpoint.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list with all the links to access to the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getAccessAtKG(self):\n\"\"\"\n    Get the ways in which you can access the KG. This information is retrived by analyzing the metadata and/or querying the SPARQL endpoint.\n    Returns:\n        list: A list with all the links to access to the KG.\n    \"\"\"\nlinks = []\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nresources = aggregator.getOtherResources(self.id)\nresources = utils.insertAvailability(resources)\nlinks = links + utils.getLinkDownload(resources)\nif isinstance(url,str):\nlinks.append(url)\ntry:\nurlList = q.checkDataDump(url)\nif isinstance(urlList,list):\nactiveUrl = utils.getActiveDumps(urlList)\nlinks = links + activeUrl\nexcept:\npass\nelif not isinstance(voidFile,bool):\nlinks = links + VoIDAnalyses.getDataDump(voidFile)\nlinks = list(dict.fromkeys(links)) #REMOVE DUPLICATES IN THE LIST\nreturn links\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getAuthors","title":"<code>getAuthors()</code>","text":"<p>Get all KG authors. This information is retrived from the SPARQL endpoint or VOID file.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains all the authors of the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getAuthors(self):\n\"\"\"\n    Get all KG authors. This information is retrived from the SPARQL endpoint or VOID file.\n    Returns:\n        list: A list that contains all the authors of the KG.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\nauthors = q.getCreator(url)\nexcept:\nauthors = 'SPARQL endpoint offline'\nif not isinstance(voidFile,bool):\nauthors = VoIDAnalyses.getCreators(voidFile)\nelif not isinstance(voidFile,bool):\nauthors = VoIDAnalyses.getCreators(voidFile)\nelse:\nauthors = 'Impossible to retrieve vocabularies from SPARQL endopoint or VOID file'\nreturn authors\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getCentrality","title":"<code>getCentrality()</code>","text":"<p>Get the centrality of kg in the graph constructed with all the kg discoverable. At the first call of a function of the interlinking metric a file is created in the directory which contains the graph with all kg discoverable, this is to avoid the construction of the graph every time from scratch.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>A float that is the centrality of the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getCentrality(self):\n\"\"\"\n    Get the centrality of kg in the graph constructed with all the kg discoverable.\n    At the first call of a function of the interlinking metric a file is created in the directory which contains the graph with all kg discoverable, this is to avoid the construction of the graph every time from scratch.\n    Returns:\n        float: A float that is the centrality of the KG.\n    \"\"\"\ngraph = utils.checkGraphFile()\ncentrality = Graph.getCentrality(graph,self.id)\ncentratility = \"%.3f\"%centrality\nreturn float(centrality)\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getClusteringCoefficient","title":"<code>getClusteringCoefficient()</code>","text":"<p>Get the clustering coefficient of kg in the graph constructed with all the kg discoverable. At the first call of a function of the interlinking metric a file is created in the directory which contains the graph with all kg discoverable, this is to avoid the construction of the graph every time from scratch.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>A float that represent a local clustering coefficient.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getClusteringCoefficient(self):\n\"\"\"\n    Get the clustering coefficient of kg in the graph constructed with all the kg discoverable.\n    At the first call of a function of the interlinking metric a file is created in the directory which contains the graph with all kg discoverable, this is to avoid the construction of the graph every time from scratch.\n    Returns:\n        float: A float that represent a local clustering coefficient.\n    \"\"\"\ngraph = utils.checkGraphFile()\nlcc = Graph.getClusteringCoefficient(graph,self.id)\nlcc = \"%.3f\"%lcc\nreturn float(lcc)\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getContributors","title":"<code>getContributors()</code>","text":"<p>Get all the KG contributors. This information is retrived from the SPARQL endpoint or VOID file.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains all the contributors to the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getContributors(self):\n\"\"\"\n    Get all the KG contributors. This information is retrived from the SPARQL endpoint or VOID file.\n    Returns:\n        list: A list that contains all the contributors to the KG.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\ncontributors = q.getContributors(url)\nexcept:\ncontributors = 'SPARQL endpoint offline'\nif not isinstance(voidFile,bool):\ncontributors = VoIDAnalyses.getContributors(voidFile)\nelif not isinstance(voidFile,bool):\ncontributors = VoIDAnalyses.getContributors(voidFile)\nelse:\ncontributors = 'Impossible to retrieve vocabularies from SPARQL endopoint or VOID file'\nreturn contributors\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getCreationDate","title":"<code>getCreationDate()</code>","text":"<p>Get the KG creation date. This information is retrived from the SPARQL endpoint or VOID file. False is returned if SPARQL endpoint is offline</p> <p>Returns:</p> Name Type Description <code>string</code> <p>A string that is the KG creation date</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getCreationDate(self):\n\"\"\"\n    Get the KG creation date. This information is retrived from the SPARQL endpoint or VOID file. False is returned if SPARQL endpoint is offline\n    Returns:\n        string: A string that is the KG creation date  \n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\ncreationD = q.getCreationDateMin(url)\nexcept:\ncreationD = False\ntry:\ncreationD = q.getCreationDate(url)\nexcept:\ncreationD = False\nif not isinstance(voidFile,bool) and not isinstance(creationD,str):\ncreationD = VoIDAnalyses.getCreationDate(voidFile)\nelif not isinstance(voidFile,bool):\ncreationD = VoIDAnalyses.getCreationDate(voidFile)\nelse:\ncreationD = 'SPARQL endpoint and VoID absent'\nreturn creationD\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getDegreeOfConnection","title":"<code>getDegreeOfConnection()</code>","text":"<p>Get the degree of connection of kg in the graph constructed with all the kg discoverable. At the first call of a function of the interlinking metric a file is created in the directory which contains the graph with all kg discoverable, this is to avoid the construction of the graph every time from scratch.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>An integer that represent the degree of connection.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getDegreeOfConnection(self):\n\"\"\"\n    Get the degree of connection of kg in the graph constructed with all the kg discoverable.\n    At the first call of a function of the interlinking metric a file is created in the directory which contains the graph with all kg discoverable, this is to avoid the construction of the graph every time from scratch.\n    Returns: \n        int: An integer that represent the degree of connection.\n    \"\"\"\ngraph = utils.checkGraphFile()\ndegree = Graph.getDegreeOfConnection(graph,self.id)\nreturn degree\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getDescription","title":"<code>getDescription()</code>","text":"<p>Get the description of the KG by analyzing the metadata.</p> <p>Returns:</p> Name Type Description <code>string</code> <p>A string that contains a description of the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getDescription(self):\n\"\"\"\n    Get the description of the KG by analyzing the metadata.\n    Returns:\n        string: A string that contains a description of the KG.  \n    \"\"\"\nmetadata = aggregator.getDataPackage(self.id)\ndescription = aggregator.getDescription(metadata)\nreturn description\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getDisjointValue","title":"<code>getDisjointValue()</code>","text":"<p>Get the disjoint value. It is calculated by counting the number of triples with predicate owl:disjointWith and then making the ratio between number of triples with that predicate and number of entities.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>A float that represent the disjoint value if triples and entity is recovered correctly form SPARQL endpoint.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getDisjointValue(self):\n\"\"\"\n    Get the disjoint value. It is calculated by counting the number of triples with predicate owl:disjointWith and then making the ratio between number of triples with that predicate and number of entities.\n    Returns:\n        float: A float that represent the disjoint value if triples and entity is recovered correctly form SPARQL endpoint.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nnumDisjoint = q.getDisjoint(url)\nnumEntities = q.getNumEntities(url)\nif not isinstance(numEntities,int):\nregex = []\nregex = q.checkUriRegex(url)\npattern = q.checkUriPattern(url)\nfor p in pattern:\nnewRegex = utils.trasforrmToRegex(p)\nregex.append(newRegex)\nif len(regex) &gt; 0:\nnumEntities = 0\nfor r  in regex:\nnumEntities = numEntities + q.getNumEntitiesRegex(url,r)\nif isinstance(numDisjoint,int):\ntry:\nnumEntities = int(numEntities)\nif numEntities &gt; 0:\ndisjointValue = numDisjoint/numEntities\ndisjointValue = \"%.3f\"%disjointValue\ndisjointValue = float(disjointValue)\nelse:\ndisjointValue = 'insufficient data'\nexcept:\ndisjointValue = 'insufficient data'   \nreturn disjointValue     \nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'   \nexcept Exception as e:\nreturn e\nelse:\nreturn 'SPARQL endpoint absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getExtensionaConc","title":"<code>getExtensionaConc()</code>","text":"<p>Get the extensional conciseness value, it is calculated by the following formula: 1.0 - #duplicated triples (calculated with Bloom filter algorithm) / #triples in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>A float that is the extensional conciseness value.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getExtensionaConc(self):\n\"\"\"\n    Get the extensional conciseness value, it is calculated by the following formula: 1.0 - #duplicated triples (calculated with Bloom filter algorithm) / #triples in the dataset.\n    Returns:\n        float: A float that is the extensional conciseness value.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nallTriples = q.getAllTriplesSPO(url)\ntripleList = []\nduplicate = []\nif isinstance(allTriples,list):\nif len(allTriples)&gt; 0:    \nfor i in range(len(allTriples)):\ns = allTriples[i].get('s')\np = allTriples[i].get('p')\no = allTriples[i].get('o')\nsubject = s.get('value')\npredicate = p.get('value')\nobject = o.get('value')\ntriple = subject + predicate + object\ntripleList.append(triple)\nbloomF = BloomFilter(len(tripleList),0.05)\nprint(\"Size of bit array:{}\".format(bloomF.size))\nprint(\"False positive Probability:{}\".format(bloomF.fp_prob))\nprint(\"Number of hash functions:{}\".format(bloomF.hash_count))\nfor i in range(len(tripleList)):\nfound = bloomF.check(tripleList[i])\nif found == False:\nbloomF.add(tripleList[i])\nelif found == True:\nduplicate.append(tripleList[i])\nif len(allTriples) &gt; 0:\nexC = 1.0 - (len(duplicate)/len(allTriples)) # From: Evaluating the Quality of the LOD Cloud: An Empirical Investigation (Ruben Verborgh)\nexC = \"%.3f\"%exC\nexC = float(exC)\nelse:\nexC = 'insufficient data'\nelse:\nexC = '0 triples retrieved from the endpoint'\nelse:\nexC = 'insufficient data'\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nexC = 'SPARQL endpoint offline'\nexcept:\nexC = 'Could not process formulated query on indicated endpoint'\nreturn exC\nelse:\nreturn 'SPARQL endpoint absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getExternalProvider","title":"<code>getExternalProvider()</code>","text":"<p>Return a dict with all external provider the key is the id of the KG it is connected to and the value is the number of triples connected, this information is obtained by analyzing the metadata.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dict with all external provider.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getExternalProvider(self):\n\"\"\"\n    Return a dict with all external provider the key is the id of the KG it is connected to and the value is the number of triples connected, this information is obtained by analyzing the metadata.\n    Returns:\n        dict: A dict with all external provider.\n    \"\"\"\nextLinks = aggregator.getExternalLinks(self.id)\nreturn extLinks\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getFrequencyUp","title":"<code>getFrequencyUp()</code>","text":"<p>Get the KG update frequency. This information is retrived from SPARQL endpoint or VOID file.</p> <p>Returns:</p> Name Type Description <code>string</code> <p>A string that contains the KG update frequency.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getFrequencyUp(self):\n\"\"\"\n    Get the KG update frequency. This information is retrived from SPARQL endpoint or VOID file.\n    Returns:\n        string: A string that contains the KG update frequency.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\nfrequency = q.getFrequency(url)\nexcept:\nfrequency = 'SPARQL endpoint offline'\nif not isinstance(voidFile,bool):\nfrequency = VoIDAnalyses.getFrequency(voidFile)\nelif not isinstance(voidFile,bool):\nfrequency = VoIDAnalyses.getFrequency(voidFile)\nelse:\nfrequency = 'SPARQL endpoint and VoID file absent'\nreturn frequency\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getIntensionalConc","title":"<code>getIntensionalConc()</code>","text":"<p>Get the intensional conciseness value, it is calculated by the following formula: 1.0 - #duplicated properties (calculated with Bloom filter algorithm)/#triples in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>A float that is the intensional conciseness value.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getIntensionalConc(self):\n\"\"\"\n    Get the intensional conciseness value, it is calculated by the following formula: 1.0 - #duplicated properties (calculated with Bloom filter algorithm)/#triples in the dataset.\n    Returns:\n        float: A float that is the intensional conciseness value.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nallProperty = q.getAllPropertySP(url)\ntriplePropList = []\nduplicateP = []\nif isinstance(allProperty,list):\nif len(allProperty) &gt; 0:\nfor i in range(len(allProperty)):\ns = allProperty[i].get('s')\np = allProperty[i].get('p')\nsubP = s.get('value')\npredP = p.get('value')\ntripleProp = subP + predP\ntriplePropList.append(tripleProp)\nbloomF2 = BloomFilter(len(triplePropList),0.05)\nfor j in range(len(triplePropList)):\nfound = bloomF2.check(triplePropList[j])\nif found == False:\nbloomF2.add(triplePropList[j])\nelif found == True:\nduplicateP.append(triplePropList[j])\nif len(allProperty) &gt; 0:\nintC = 1.0 - (len(duplicateP)/len(allProperty))\nintC = \"%.3f\"%intC\nintC = float(intC)\nelse:\nintC = 'insufficient data'\nelse:\nintC = '0 properties retrieved from the endpoint'\nelse:\nintC = 'insufficient data'\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nintC = 'SPARQL endpoint offline'\nexcept:\nintC = 'Could not process formulated query on indicated endpoint'\nreturn intC\nelse:\nreturn 'SPARQL endpoint absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getInterlinkingComp","title":"<code>getInterlinkingComp()</code>","text":"<p>Calcuate the interlinking completeness. It is calculated by the ratio between the number of linked triples and number of all triples in the dataset.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>An integer that is the interlinking completeness of the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getInterlinkingComp(self):\n\"\"\"\n    Calcuate the interlinking completeness. It is calculated by the ratio between the number of linked triples and number of all triples in the dataset.\n    Returns:\n        int: An integer that is the interlinking completeness of the KG.\n    \"\"\"\nexternalLinks = aggregator.getExternalLinks(self.id)\nexLinksObj = utils.toObjectExternalLinks(externalLinks)\ntriplesL = 0\nfor i in range(len(exLinksObj)): #COUNTING THE NUMBER OF TRIPLES CROSS EXTERNAL LINK LIST IN THE METADATA\nlink = exLinksObj[i]\nvalue = link.value\nvalue = str(link.value)\nvalue = re.sub(\"[^\\d\\.]\", \"\",value) #CHECK IF THE VALUE IS A NUMBER\nvalue = int(value)\ntriplesL = triplesL + value\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\ntriples = q.getNumTripleQuery(url) #COUNT THE NUMBER OF TRIPLES WITH A SPARQL QUERY\nexcept:   #IF SPARQL ENDPOINT IS OFFLINE, COUNT THE TRIPLES BY ANALYZING THE METADATA\ntriples = 'SPARQL endpoint offline'\nmetadata = aggregator.getDataPackage(self.id)\ntriples = aggregator.getTriples(metadata)\nelse:\ntriples = 'SPARQL endpoint and VoID file absent'\ntry:\ntriplesL = int(triplesL)\ntriples = int(triples)\nif triples &gt; 0:\niCompl = (triplesL/triples)\niCompl = \"%.2f\"%iCompl\niCompl = float(iCompl)\nelse:\niCompl = 'Insufficient data'\nexcept:\niCompl = 'Insufficient data'\nreturn iCompl\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getLanguages","title":"<code>getLanguages()</code>","text":"<p>Get the languages supported by the KG. This information is retrieved by querying the SPARQL endpoint.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list with all the languages supprted by the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getLanguages(self):\n\"\"\"\n    Get the languages supported by the KG. This information is retrieved by querying the SPARQL endpoint.\n    Returns:\n        list: A list with all the languages supprted by the KG.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nlanguages = q.getLangugeSupported(url)\nexcept:\nlanguages = 'SPARQL endpoint offline'\nelse:\nlanguages = 'SPARQL endpoint absent'\nreturn languages\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getLastUp","title":"<code>getLastUp()</code>","text":"<p>Get the elapsed time since the last modification (in days).</p> <p>Returns:</p> Name Type Description <code>string</code> <p>A string that represent the days that have passed since the last modification.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getLastUp(self):\n\"\"\"\n    Get the elapsed time since the last modification (in days).\n    Returns:\n        string: A string that represent the days that have passed since the last modification.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\nmodificationD = q.getModificationDateMax(url)\nexcept:\nmodificationD = False\ntry:\nmodificationD = q.getModificationDate(url)\nexcept:\nmodificationD = False\nif not isinstance(voidFile,bool) and not isinstance(modificationD,str):\nmodificationD = VoIDAnalyses.getCreationDate(voidFile)\nelif not isinstance(voidFile,bool):\nmodificationD = VoIDAnalyses.getCreationDate(voidFile)\nelse:\nmodificationD = 'SPARQL endpoint and VoID absent'\ntry:\ntoday = datetime.date.today()\ntodayFormatted = today.strftime(\"%Y-%m-%d\")\ntodayDate =  datetime.datetime.strptime(todayFormatted, \"%Y-%m-%d\").date()\nmodificationD = datetime.datetime.strptime(modificationD, \"%Y-%m-%d\").date()\ndelta = (todayDate - modificationD).days\nexcept:\ndelta = 'Insufficient data'\nreturn delta\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getLatency","title":"<code>getLatency()</code>","text":"<p>Get the latency of the sparql endpoint, is the time passed between the request for a triple and when is returned. The value returned is the average latency  of the 5 attempts performed.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>A float that is the average latency if SPARQL endpoint is online.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getLatency(self):\n\"\"\"\n    Get the latency of the sparql endpoint, is the time passed between the request for a triple and when is returned.\n    The value returned is the average latency  of the 5 attempts performed.\n    Returns:\n        float: A float that is the average latency if SPARQL endpoint is online.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nlatency = q.testLatency(url)\nsumL = sum(latency)\naverage = sumL/len(latency)\nreturn average\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept Exception as e:\nreturn e\nelse:\nreturn 'SPARQL endpoint absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getLicenseHR","title":"<code>getLicenseHR()</code>","text":"<p>Get the human-redeable license, search for a label on the triples in the KG.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list which contain all the human-redeable license founded in the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getLicenseHR(self):\n\"\"\"\n    Get the human-redeable license, search for a label on the triples in the KG.\n    Returns:\n        list: A list which contain all the human-redeable license founded in the KG.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\ntry:\nlicense = q.checkLicenseHR(url)\nexcept Exception as e:\nlicense = e\nreturn license\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getLicenseMR","title":"<code>getLicenseMR()</code>","text":"<p>Return the machine-redeable license of the kg, checking on the SPARQL endpopint, in the metadata and in the void file .</p> <p>Returns:</p> Name Type Description <code>string</code> <p>A string that represent the machine-redeable license of the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getLicenseMR(self):\n\"\"\"\n    Return the machine-redeable license of the kg, checking on the SPARQL endpopint, in the metadata and in the void file .\n    Returns:\n        string: A string that represent the machine-redeable license of the KG.\n    \"\"\"\nmetadata = aggregator.getDataPackage(self.id)\nlicenseM = aggregator.getLicense(metadata) #CHECKING IN THE METADATA\nif isinstance(licenseM,str): \nreturn licenseM   #IF LICENSE IS INDICATED IN THE METADATE, RETURN IT\ntry:\nlicenseQ = q.checkLicenseMR2(aggregator.getSPARQLEndpoint(self.id)) #CHECKING ON THE SPARQL ENDPOINT\nif isinstance(licenseQ,list):\nreturn licenseQ\nexcept Exception as e:\nreturn e\nresources = aggregator.getOtherResources(self.id)\nresources = utils.insertAvailability(resources)\notResources = utils.toObjectResources(resources)\nurlV = utils.getUrlVoID(otResources)\nif isinstance(urlV,str):  # CHECKING IF VOID FILE IS AVAILABLE\ntry:\nvoidFile = VoIDAnalyses.parseVoID(urlV)\nvoid = True\nexcept:\ntry:\nvoidFile = VoIDAnalyses.parseVoIDTtl(urlV)\nvoid = True\nexcept:\nvoid = False \nif void == True:\nlicenseV = VoIDAnalyses.getLicense(voidFile)  #GETTING LICENSE FROM THE VOID FILE\nif isinstance(licenseV,str):\nreturn licenseV\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getModificationDate","title":"<code>getModificationDate()</code>","text":"<p>Get the KG modification date. This information is retrived from SPARQL endpoint or VOID file. False is returned if SPARQL endpoint is offline.</p> <p>Returns:</p> Name Type Description <code>string</code> <p>A string that contains a KG modification date.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getModificationDate(self):\n\"\"\"\n    Get the KG modification date. This information is retrived from SPARQL endpoint or VOID file. False is returned if SPARQL endpoint is offline.\n    Returns:\n        string: A string that contains a KG modification date.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\nmodificationD = q.getModificationDateMax(url)\nexcept:\nmodificationD = False\ntry:\nmodificationD = q.getModificationDate(url)\nexcept:\nmodificationD = False\nif not isinstance(voidFile,bool) and not isinstance(modificationD,str):\nmodificationD = VoIDAnalyses.getCreationDate(voidFile)\nelif not isinstance(voidFile,bool):\nmodificationD = VoIDAnalyses.getCreationDate(voidFile)\nelse:\nmodificationD = 'SPARQL endpoint and VoID absent'\nreturn modificationD\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getName","title":"<code>getName()</code>","text":"<p>Get the title of the KG by analyzing the metadata.</p> <p>Returns:</p> Name Type Description <code>string</code> <p>A string that contains the title of the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getName(self):\n\"\"\"\n    Get the title of the KG by analyzing the metadata.\n    Returns:\n        string: A string that contains the title of the KG.\n    \"\"\"\nmetadata = aggregator.getDataPackage(self.id)\ntitle = aggregator.getNameKG(metadata)\nreturn title\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getNumEntities","title":"<code>getNumEntities()</code>","text":"<p>Count the number of entities in the dataset. This information can be obtained by a SPARQL endpoint or analyzing the VoID file.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>An integer that is the number of entities in the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getNumEntities(self):\n\"\"\"\n    Count the number of entities in the dataset. This information can be obtained by a SPARQL endpoint or analyzing the VoID file.\n    Returns:\n        int: An integer that is the number of entities in the KG.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\nentities = q.getNumEntities(url)\ntry:\nentities = int(entities)\nreturn entities\nexcept:  #IF WITH THE FIRST QUERY WE DON'T GET THE RESULT, WE TRY TO COUNT THE NUMBER OF ENTITIES BY COUNTING THE NUMBER OF TRIPLES THAT MATH WITH THEKG URI REGEX\n#GET THE REGEX OF THE URLs USED\nregex = []\ntry:\nregex = q.checkUriRegex(url)\nexcept:\nregex = 'Could not process formulated query on indicated enpdoint'\n#CHECK IF IS INDICATED A URI SPACE INSTEAD OF A REGEX AND WE TRAFORM IT TO REGEX\ntry:    \npattern = q.checkUriPattern(url)  \nif isinstance(pattern,list):\nfor i in range(len(pattern)): \nnewRegex = utils.trasforrmToRegex(pattern[i])\nregex.append(newRegex)\nexcept:\npattern = 'Could not process formulated query on indicated enpdoint'\n#NOW COUNT THE ENITITIES USING THE REGEX\ntry:\nif len(regex) &gt; 0:\nentities = 0\nfor i in range(len(regex)):\nentities = entities + q.getNumEntitiesRegex(url,regex[i])\nelse:\nentities = 'insufficient data'\nexcept Exception as e:\nentities = e\nreturn entities\nexcept:\nif not isinstance(voidFile,bool):\nentities = VoIDAnalyses.getNumEntities(voidFile)\nreturn entities\nelif not isinstance(voidFile,bool):\nentities = VoIDAnalyses.getNumEntities(voidFile)\nreturn entities\nelse:\nreturn 'SPARQL endpoint and VoID file absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getNumLabels","title":"<code>getNumLabels()</code>","text":"<p>Count the number of label on the triples in the KG. This count is done by using a query on the SPARQL endpoint.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>An integer that is the number of label in the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getNumLabels(self):\n\"\"\"\n    Count the number of label on the triples in the KG. This count is done by using a query on the SPARQL endpoint.\n    Returns:\n        int: An integer that is the number of label in the KG.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nnumLabel = q.getNumLabel(url)\nexcept:\nnumLabel = 'SPARQL endpoint offline'\nelse:\nnumLabel = 'SPARQL endpoint absent'\nreturn numLabel\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getNumProperty","title":"<code>getNumProperty()</code>","text":"<p>Get the number of property in the KG. This information is retrived by executing a query on the SPARQL endpoint.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>An integer that is the number of properties in the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getNumProperty(self):\n\"\"\"\n    Get the number of property in the KG. This information is retrived by executing a query on the SPARQL endpoint.\n    Returns:\n        int: An integer that is the number of properties in the KG.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nnumProperty = q.numberOfProperty(url)\nexcept:\nnumProperty = 'SPARQL endpoint offline'\nelse:\nnumProperty = 'SPARQL endpoint absent'\nreturn numProperty\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getNumTriples","title":"<code>getNumTriples()</code>","text":"<p>Get the number of triples in the KG. This information can be obtained by SPARQL endpoint or analyzing the metadata of the dataset.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>An integer that is the number of triples.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getNumTriples(self):\n\"\"\"\n    Get the number of triples in the KG. This information can be obtained by SPARQL endpoint or analyzing the metadata of the dataset.\n    Returns:\n        int: An integer that is the number of triples.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nmetadata = aggregator.getDataPackage(self.id)\nif isinstance(url,str):\ntry:\ntriples = q.getNumTripleQuery(url)\nexcept:\ntriples = 'SPARQL endpoint offline'\ntriples = aggregator.getTriples(metadata)\nelse:\ntriples = aggregator.getTriples(metadata)\nreturn triples\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getNumbBN","title":"<code>getNumbBN()</code>","text":"<p>Get the blank node number. This is obtained by querying the SPARQL endpoint.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>An integer that represent the number of blank node in the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getNumbBN(self):\n\"\"\"\n    Get the blank node number. This is obtained by querying the SPARQL endpoint.\n    Returns:    \n        int: An integer that represent the number of blank node in the KG.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nnumBlankN = q.numBlankNode(url)\nexcept:\nnumBlankN = 'SPARQL endpoint offline'\nelse:\nnumBlankN = 'SPARQL endpoint absent'\nreturn numBlankN\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getPageRank","title":"<code>getPageRank()</code>","text":"<p>Get the pagerank of KG based on the graph constructed with all the kg discoverable.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>A float that represent the pagerank value.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getPageRank(self):\n\"\"\"\n    Get the pagerank of KG based on the graph constructed with all the kg discoverable.\n    Returns:\n        float: A float that represent the pagerank value.\n    \"\"\"\ngraph = utils.checkGraphFile()\npageRank = Graph.getPageRank(graph,self.id)\npageRank = \"%.4f\"%pageRank\nreturn float(pageRank)\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getPercentageUpData","title":"<code>getPercentageUpData(modificationDate)</code>","text":"<p>Get the percentage of updated data. The percentage is calcualted based on the modificationDate given as a parameter.</p> <p>Returns:</p> Name Type Description <code>string</code> <p>A percentage of updated data.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getPercentageUpData(self,modificationDate):\n\"\"\"\n    Get the percentage of updated data. The percentage is calcualted based on the modificationDate given as a parameter.\n    Returns:\n        string: A percentage of updated data.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nnumTriplesUp = q.getNumUpdatedData(url,modificationDate)\nexcept:\nnumTriplesUp = 'SPARQL endpoint offline'\nelse:\nnumTriplesUp = 'SPARQL endpoint absent'\nreturn numTriplesUp\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getPublishers","title":"<code>getPublishers()</code>","text":"<p>Get all the KG pubilshers. This information is retrived from the SPARQL endpoint or VOID file.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains the publishers of the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getPublishers(self):\n\"\"\"\n    Get all the KG pubilshers. This information is retrived from the SPARQL endpoint or VOID file.\n    Returns:\n        list: A list that contains the publishers of the KG.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\npublishers = q.getPublisher(url)\nexcept:\npublishers = 'SPARQL endpoint offline'\nif not isinstance(voidFile,bool):\npublishers = VoIDAnalyses.getPublishers(voidFile)\nelif not isinstance(voidFile,bool):\npublishers = VoIDAnalyses.getPublishers(voidFile)\nelse:\npublishers = 'Impossible to retrieve vocabularies from SPARQL endopoint or VOID file'\nreturn publishers\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getRegex","title":"<code>getRegex()</code>","text":"<p>Return the uri regex of the KG. This check id done by using a query on the SPARQL endpoin or by analyzing the VoID file if available.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list with the URI regex</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getRegex(self):\n\"\"\"\n    Return the uri regex of the KG. This check id done by using a query on the SPARQL endpoin or by analyzing the VoID file if available.\n    Returns:\n        list: A list with the URI regex\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\nregex = []\ntry:\nregex = q.checkUriRegex(url)\nexcept Exception as e:\nregex = 'SPARQL endpoint offline'\nif not isinstance(voidFile,bool):\nregex = VoIDAnalyses.getUriRegex(voidFile) \n#CHECK IF IS INDICATED A URI SPACE INSTEAD OF A REGEX AND WE TRAFORM IT TO REGEX\ntry:    \npattern = q.checkUriPattern(url)  \nif isinstance(pattern,list):\nfor i in range(len(pattern)): \nnewRegex = utils.trasforrmToRegex(pattern[i])\nregex.append(newRegex)\nexcept:\npattern = 'SPARQL endpoint offline'\nelif not isinstance(voidFile,bool):\nregex = VoIDAnalyses.getUriRegex(voidFile)\nelse:\nregex = 'SPARQL endpint absent'\nreturn regex\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getSameAsChains","title":"<code>getSameAsChains()</code>","text":"<p>Return the number of sameAs chains, counting the triples with the predicate equal to owl:sameAs.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>A integer that is the number of sameAs chains.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getSameAsChains(self):\n\"\"\"\n    Return the number of sameAs chains, counting the triples with the predicate equal to owl:sameAs.\n    Returns:\n        int: A integer that is the number of sameAs chains.\n    \"\"\"\ntry:\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\nnumSameAs = q.getSameAsChains(url)\nelse:\nnumSameAs = 'SPARQL endpoint absent'\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nnumSameAs = 'SPARQL endpoint offline'\nexcept Exception as e:\nnumSameAs = e\nreturn numSameAs\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getSerializationFormat","title":"<code>getSerializationFormat()</code>","text":"<p>Get the KG serialization formats. This information is retrived by executing a query on the SPARQL endpoint or from VoID file if available.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains all the serialization formats supported by the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getSerializationFormat(self):\n\"\"\"\n    Get the KG serialization formats. This information is retrived by executing a query on the SPARQL endpoint or from VoID file if available.\n    Returns:\n        list: A list that contains all the serialization formats supported by the KG.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\nformats = q.checkSerialisationFormat(url)\nexcept:\nformats = 'SPARQL endpoint offline'\nif not isinstance(voidFile,bool):\nformats = VoIDAnalyses.getSerializationFormats(voidFile)\nelif not isinstance(voidFile,bool):\nformats = VoIDAnalyses.getSerializationFormats(voidFile)\nelse:\nformats = 'SPARQL endpoint and VoID file absent'\nreturn formats\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getSources","title":"<code>getSources()</code>","text":"<p>Get the KG sources. This return a Sources object that contains three field: web, email, name.</p> <p>Returns:</p> Type Description <p>Sources object: A Sources object that contain information about web address, email, name authors or maintainer.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getSources(self):\n\"\"\"\n    Get the KG sources. This return a Sources object that contains three field: web, email, name.\n    Returns:\n        Sources object: A Sources object that contain information about web address, email, name authors or maintainer.\n    \"\"\"\nmetadata = aggregator.getDataPackage(self.id)\nsources = aggregator.getSource(metadata)\nif sources == False:\nsourcesObj = Sources('Absent','Absent','Absent')\nelse:\nsourcesObj = Sources(sources.get('web','Absent'),sources.get('name','Absent'),sources.get('email','Absent'))\nreturn sourcesObj  #use sourcesKG() to print information about sources\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getThroughput","title":"<code>getThroughput()</code>","text":"<p>Get the throughput of the sparql endpoint, is the number of triples obtained by the endpoint in one second. The value returned is the average thrpughput of the 5 attempts performed.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>A float that represent the throughput of the SPARQL endpoint.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getThroughput(self):\n\"\"\"\n    Get the throughput of the sparql endpoint, is the number of triples obtained by the endpoint in one second.\n    The value returned is the average thrpughput of the 5 attempts performed.\n    Returns:\n        float: A float that represent the throughput of the SPARQL endpoint.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\ntp = utils.getThroughput(url)\nsumTP = sum(tp)\naverage = sumTP/len(tp)\nreturn average\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept Exception as e:\nreturn e\nelse:\nreturn 'SPARQL endpoint absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getURIsDef","title":"<code>getURIsDef()</code>","text":"<p>Check the URIs deferenceability. This test is done based on 5000 triples retrieved randomly from the SPARQL endpoint, and for each triple a GET requests is performed.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>A float that represent a value which is the ratio between: number of deferenceable URIs and number of total URIs considered.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getURIsDef(self):\n\"\"\"\n    Check the URIs deferenceability. This test is done based on 5000 triples retrieved randomly from the SPARQL endpoint, and for each triple a GET requests is performed.\n    Returns:\n        float: A float that represent a value which is the ratio between: number of deferenceable URIs and number of total URIs considered.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\ntry:\ndefCount = 0\nuriCount = 0\nuris = q.getUris(url) #QUERY THAT GET 5000 RANDOM URI FROM THE ENDPOINT \nfor uri in uris:\nif utils.checkURI(uri) == True:\nuriCount = uriCount + 1\ntry:\nresponse = requests.get(uri,headers={\"Accept\":\"application/rdf+xml\"},stream=True)\nif response.status_code == 200:\ndefCount = defCount +1\nexcept:\ncontinue\nif uriCount &gt; 0:        \ndefValue = defCount / uriCount\nelse:\ndefValue = 'No uri retrieved from the endpoint'\nexcept: #IF QUERY FAILS (BECUASE SPARQL 1.1 IS NOT SUPPORTED) TRY TO CHECK THE DEFERETIABILITY BY FILTERING THE TRIPLES RECOVERED FOR OTHER CALCULATION (IF THEY ARE BEEN RECOVERED)\ntry:\nuriCount = 0\ndefCount = 0\nallTriples = q.getAllTriplesSPO(url)\nfor i in range(5000):\ns = allTriples[i].get('s')\nvalue = s.get('value')\nif utils.checkURI(value):\nuriCount = uriCount + 1\ntry:\nresponse = requests.get(value,headers={\"Accept\":\"application/rdf+xml\"},stream=True)\nif response.status_code == 200:\ndefCount = defCount +1\nexcept:\ncontinue\nif uriCount &gt; 0:\ndefValue = defCount / uriCount\nelse:\ndefValue = 'No uri found'\nexcept:\ndefValue = 'Could not process formulated query on indicated endpoint'\nreturn defValue\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getUndefinedClass","title":"<code>getUndefinedClass()</code>","text":"<p>Get the classes used without declaration.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains undefined classes</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getUndefinedClass(self):\n\"\"\"\n    Get the classes used without declaration.\n    Returns:\n        list: A list that contains undefined classes\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nallTriples = q.getAllTriplesSPO(url)\nallType = q.getAllType(url)\ntoSearch = []\nfound = False\nfor i in range(len(allTriples)):\ns = allTriples[i].get('s')\ns = s.get('value')\nallType.sort()\nr = utils.binarySearch(allType,0,len(allType)-1,s)\nif r != -1:\nfound = True\nbreak\nif found == False:\nresult = utils.checkURI(s)\nif result == True:\ntoSearch.append(s)\nfound = False\nundClasses = LOVAPI.searchTermsList(toSearch)\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nreturn 'SPARQL endpoint offline'\nexcept Exception as e:\nreturn e\nreturn undClasses\nelse:\nreturn 'SPARQL endpoint absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getUndefinedProp","title":"<code>getUndefinedProp()</code>","text":"<p>Get the properties used without declaration.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains a list of undefined properties.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getUndefinedProp(self):\n\"\"\"\n    Get the properties used without declaration.\n    Returns:\n        list: A list that contains a list of undefined properties. \n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nuriListP = q.getAllPredicate(url)\nproperties = q.getAllProperty(url)\ntoSearch = []\nfound = False\nfor i in range(len(uriListP)):\np = uriListP[i]\nproperties.sort()\nr = utils.binarySearch(properties,0,len(properties)-1,p)\nif r != -1:\nfound = True\nbreak\nif found == False:\nresult = utils.checkURI(p)\nif result == True:\ntoSearch.append(p)\nfound = False\nundProperties = LOVAPI.searchTermsList(toSearch)\nexcept (HTTPError,URLError,SPARQLExceptions.EndPointNotFound,socket.gaierror,SPARQLExceptions.EndPointInternalError,json.JSONDecodeError, SPARQLExceptions.QueryBadFormed,SPARQLExceptions.Unauthorized):\nundProperties = 'SPARQL endpoint offline'\nexcept :\nundProperties = 'Could not process formulated query on indicated endpoint'\nreturn undProperties\nelse:\nreturn 'SPARQL endpoint absent'\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getUri","title":"<code>getUri()</code>","text":"<p>Get the URI of the KG by analyzing the metadata.</p> <p>Returns:</p> Name Type Description <code>string</code> <p>A tring that is the URI of the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getUri(self):\n\"\"\"\n    Get the URI of the KG by analyzing the metadata.\n    Returns:\n        string: A tring that is the URI of the KG.\n    \"\"\"\nmetadata = aggregator.getDataPackage(self.id)\nsources = aggregator.getSource(metadata)\nurl = sources.get('web','Absent')\nreturn url\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getUriLenghtObj","title":"<code>getUriLenghtObj()</code>","text":"<p>Get the uri's length in the object position. The returned value is a list in which the values are respectively min-max-average-standard deviation.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains all the URI in the object position</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getUriLenghtObj(self):\n\"\"\"\n    Get the uri's length in the object position. The returned value is a list in which the values are respectively min-max-average-standard deviation.\n    Returns:\n        list: A list that contains all the URI in the object position\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nuriListO = q.getAllObject(url)\nlengthtList = []\nfor triple in uriListO:\nif utils.checkURI(triple) == True:\nlengthtList.append(len(triple))\nsumLenghts = sum(lengthtList)\navLenghts = sumLenghts/len(lengthtList) \navLenghts = str(avLenghts)\navLenghts = avLenghts.replace('.',',')\nstandardDeviationL = numpy.std(lengthtList)\nstandardDeviationL = str(standardDeviationL)\nstandardDeviationL = standardDeviationL.replace('.',',')\nminLenghtS = min(lengthtList)\nmaxLenghtS = max(lengthtList)\nlength = [minLenghtS,maxLenghtS,avLenghts,standardDeviationL]\nexcept:\nlength = 'SPARQL endpoint offline'\nelse:\nlength = 'SPARQL endpoint absent'\nreturn length\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getUriLenghtPr","title":"<code>getUriLenghtPr()</code>","text":"<p>Get the uri's length in the predicate position. The returned value is a list in which the values are respectively min-max-average-standard deviation.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains URIs in the predicate position.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getUriLenghtPr(self):\n\"\"\"\n    Get the uri's length in the predicate position. The returned value is a list in which the values are respectively min-max-average-standard deviation.\n    Returns:\n        list: A list that contains URIs in the predicate position.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nuriListP = q.getAllPredicate(url)\nlengthtList = []\nfor triple in uriListP:\nif utils.checkURI(triple) == True:\nlengthtList.append(len(triple))\nsumLenghts = sum(lengthtList)\navLenghts = sumLenghts/len(lengthtList) \navLenghts = str(avLenghts)\navLenghts = avLenghts.replace('.',',')\nstandardDeviationL = numpy.std(lengthtList)\nstandardDeviationL = str(standardDeviationL)\nstandardDeviationL = standardDeviationL.replace('.',',')\nminLenghtS = min(lengthtList)\nmaxLenghtS = max(lengthtList)\nlength = [minLenghtS,maxLenghtS,avLenghts,standardDeviationL]\nexcept:\nlength = 'SPARQL endpoint offline'\nelse:\nlength = 'SPARQL endpoint absent'\nreturn length\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getUriLenghtSub","title":"<code>getUriLenghtSub()</code>","text":"<p>Get the uri's length in the subject position. The returned value is a list in which the values are respectively min-max-average-standard deviation.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains all the URI in the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getUriLenghtSub(self):\n\"\"\"\n    Get the uri's length in the subject position. The returned value is a list in which the values are respectively min-max-average-standard deviation.\n    Returns:\n        list: A list that contains all the URI in the KG.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nif isinstance(url,str):\ntry:\nlengthtList = []\ntriples = q.getAllTriplesSPO(url)\nfor triple in triples:\ns = triple.get('s')\nuri = s.get('value')\nif utils.checkURI(uri) == True:\nlengthtList.append(len(uri))\nsumLenghts = sum(lengthtList)\navLenghts = sumLenghts/len(lengthtList) \navLenghts = str(avLenghts)\navLenghts = avLenghts.replace('.',',')\nstandardDeviationL = numpy.std(lengthtList)\nstandardDeviationL = str(standardDeviationL)\nstandardDeviationL = standardDeviationL.replace('.',',')\nminLenghtS = min(lengthtList)\nmaxLenghtS = max(lengthtList)\nlength = [minLenghtS,maxLenghtS,avLenghts,standardDeviationL]\nexcept:\nlength = 'SPARQL endpoint offline'\nelse:\nlength = 'SPARQL endpoint absent'\nreturn length\n</code></pre>"},{"location":"knowledge_graph/#kgheartbeat.knowledge_graph.KnowledgeGraph.getVocabularies","title":"<code>getVocabularies()</code>","text":"<p>Get all the vocabularies used in the KG. This information is retrived from the SPARQL endpoint or VOID file.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list that contains all the vocabularies used in the KG.</p> Source code in <code>kgheartbeat\\knowledge_graph.py</code> <pre><code>def getVocabularies(self):\n\"\"\"\n    Get all the vocabularies used in the KG. This information is retrived from the SPARQL endpoint or VOID file.\n    Returns:\n        list: A list that contains all the vocabularies used in the KG.\n    \"\"\"\nurl = aggregator.getSPARQLEndpoint(self.id)\nvoidFile = utils.checkVoidFile(self.id)\nif isinstance(url,str):\ntry:\nvocabularies = q.getVocabularies(url)\nexcept:\nvocabularies = 'SPARQL endpoint offline'\nif not isinstance(voidFile,bool):  #IF SPARQL ENDPOINT IS OFFLINE TRY TO GET THE VOCABULARIES FROM VOID FILE\nvocabularies = VoIDAnalyses.getVocabularies(voidFile)\nelif not isinstance(voidFile,bool): #IF SPARQL ENDPOINT IS ABSENT TRY TO GET THE VOCABULARIES FROM VOID FILE\nvocabularies = VoIDAnalyses.getVocabularies(voidFile)\nelse:\nvocabularies = 'Impossible to retrieve vocabularies from SPARQL endopoint or VOID file'\nreturn vocabularies\n</code></pre>"},{"location":"reference/","title":"Reference","text":"<p>Here you can see the documentation for every modules in the project.</p> <p>knowledge_graph.py</p> <p>AGAPI.py</p> <p>aggregator.py</p> <p>DataHubAPI.py</p> <p>Graph.py</p> <p>LODCloudAPI.py</p> <p>LOVAPI.py</p> <p>VoIDAnalyses.py</p>"},{"location":"tutorials/","title":"Examples","text":""},{"location":"tutorials/#examples","title":"Examples","text":"<p>All of the following examples assume that the library has been installed with the following command.</p> <pre><code>pip install kgheartbeat\n</code></pre>"},{"location":"tutorials/#calculate-the-availability-dimension","title":"Calculate the Availability dimension","text":"<p>This example show how calculate the availability of a KG, we need to calculate all the metrics connected to them. Suppose we want to calculate the availability for DBpedia.</p> <pre><code>from kgheartbeat import KnowledgeGraph\n# Instanziate a KnowledgeGraph class, passing the id of the kg to be analyzed\nkg = KnowledgeGraph('dbpedia')\n# Check the SPARQL endpoint availability\nsparqlAv = kg.checkEndpointAv()\n# Check if the links for download the dataset is up\ncheckDump = kg.checkDownload()\n# Check if there are any inactive links\ninactiveLks = kg.checkInactiveLinks()\n# Calculate the URI's deferenceability (based on 5000 randomly recoverable uri). THIS COULD TAKE TIME, DEPENDS ON THE SPEED OF THE ENDPOINT (~45 min. for DBpedia)\nuriDef = kg.getURIsDef()\n#Print all the results\nprint(f\"SPARQL endpoint availability: {sparqlAv}\\n \\\n       RDF dump link availability: {checkDump}\\n\\\n       Any inactive links: {inactiveLks}\\n\\\n       URIs deferenceability: {uriDef}\")\n</code></pre>"},{"location":"tutorials/#calculate-the-licensing-dimension","title":"Calculate the Licensing dimension","text":"<p>In this example we want to calculate the licensing dimension for Taxref-ld </p> <pre><code>from kgheartbeat import KnowledgeGraph\n# Instanziate a KnowledgeGraph class, passing the id of the kg to be analyzed\nkg = KnowledgeGraph('taxref-ld')\n#Search for the machine-redeable license\nmr_license = kg.getLicenseMR()\n#Search for a human-redeable license\nhr_license = kg.getLicenseHR()\nprint(f\"Machine redeable license: {mr_license}\\nHuman-redeable license: {hr_license}\")\n</code></pre>"},{"location":"tutorials/#calculate-the-versatility-dimension","title":"Calculate the Versatility dimension","text":"<p>This is another example, in which we demostrate how calculate all the metric in the Versatility dimension.</p> <pre><code># Instanziate a KnowledgeGraph class, passing the id of the kg to be analyzed\nkg = KnowledgeGraph('bncf-ns')\n#Find the different serialization formats available (e.g. .rdf, .n3, .xml)\nformats = kg.getSerializationFormat()\n#Get languages if is indicated\nlanguages = kg.getLanguages()\n#get all the links to access the KG\nlink_access = kg.getAccessAtKG()\nprint(f\"Serialization formats: {formats}\\nLanguages: {languages}\\n Link to access the KG:{link_access}\\n\")\n</code></pre>"}]}